<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Coding Blog</title>
  <icon>https://www.gravatar.com/avatar/a8f9eea32979fcc0ed3972ee87db09aa</icon>
  <subtitle>摸学并进 躺卷交融.</subtitle>
  <link href="https://github.wilbur-lz.cn/atom.xml" rel="self"/>
  
  <link href="https://github.wilbur-lz.cn/"/>
  <updated>2024-10-07T12:45:50.394Z</updated>
  <id>https://github.wilbur-lz.cn/</id>
  
  <author>
    <name>整点薯条</name>
    <email>854309295@qq.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java基础</title>
    <link href="https://github.wilbur-lz.cn/posts/f7ede91d.html"/>
    <id>https://github.wilbur-lz.cn/posts/f7ede91d.html</id>
    <published>2024-10-07T12:45:50.394Z</published>
    <updated>2024-10-07T12:45:50.394Z</updated>
    
    <content type="html"><![CDATA[<h1 id="面向对象三大特性：封装，继承，多态"><a href="#面向对象三大特性：封装，继承，多态" class="headerlink" title="面向对象三大特性：封装，继承，多态"></a>面向对象三大特性：封装，继承，多态</h1><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h4 id="继承中构造方法的特点："><a href="#继承中构造方法的特点：" class="headerlink" title="继承中构造方法的特点："></a>继承中构造方法的特点：</h4><ul><li>父类中的构造方法不会被子类继承(否则构造方法名与类名不一致)</li><li>子类中所有的构造方法默认先访问父类中的无参构造，在执行自己</li></ul><p>使用super关键字访问父类的方法</p><h4 id="this，super关键字："><a href="#this，super关键字：" class="headerlink" title="this，super关键字："></a>this，super关键字：</h4><ul><li>this：表示当前方法调用者的地址值</li><li>super：代表父类的存储空间</li></ul><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态的表现形式：父类类型 对象名 = 子类对象</p><p>多态的前提：</p><ul><li>有继承 / 实现关系</li><li>有父类的引用指向子类对象</li><li>有方法重写</li></ul><h3 id="多态调用成员的特点："><a href="#多态调用成员的特点：" class="headerlink" title="多态调用成员的特点："></a>多态调用成员的特点：</h3><ul><li>变量调用：编译看左边，运行也看左边</li><li>方法调用：编译看左边，运行看右边</li></ul><h3 id="instanceof关键字"><a href="#instanceof关键字" class="headerlink" title="instanceof关键字"></a>instanceof关键字</h3><p>判断父类对象是否为某一特定的子类</p><h2 id="包，final，权限修饰符，代码块"><a href="#包，final，权限修饰符，代码块" class="headerlink" title="包，final，权限修饰符，代码块"></a>包，final，权限修饰符，代码块</h2><h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><p>使用规则:</p><ul><li>使用同一个包中的类是，不需要导包</li><li>java.lang包中的类不需要导包</li><li>其他情况都需要导包</li><li>如果同时使用两个包中的同名类，需要使用全类名</li></ul><h3 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h3><ul><li><p>修饰方法：表明该方法是最终方法，不能被重写</p></li><li><p>修饰类：表明该类是最终类，不能被继承</p></li><li><p>修饰变量：叫做常量，只能被赋值一次。</p><p>变量为基本类型 —-&gt; 数据值不能发生改变</p><p>变量为引用数据类型 —-&gt; 变量存储的地址值不能发生改变,对象内部的可以改变</p></li></ul><h3 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h3><p>范围从大到小：public &gt; protected &gt; 缺省 &gt; private</p><p>一般开发中只使用public 和 private，一般而言成员变量private，成员方法public。但如果方法中的代码是抽取其他方法中共性代码，这个方法也要用private修饰</p><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><ul><li>局部代码块：提前结束变量的生命周期</li><li>构造代码块：将多个构造方法中重复的部分写在成员变量的位置，优先于构造方法执行(淘汰)</li><li>静态代码块：用static修饰，随着类的加载而加载，并且自动触发，只执行一次</li></ul><h2 id="抽象类-abstract"><a href="#抽象类-abstract" class="headerlink" title="抽象类(abstract)"></a>抽象类(abstract)</h2><p>如果一个类中存在抽象方法，则这个类必须定义为抽象类</p><p>关键字abstract写在权限修饰符之后</p><ul><li>抽象类不能实例化</li><li>抽象类中不一定有抽象方法，由抽象方法的类一定是抽象类</li><li>可以有构造方法 —-&gt; 当子类创建对象时，给父类中的属性进行赋值</li><li>抽象类的子类<ol><li>要么重写抽象类中的所有抽象方法</li><li>要么也是抽象类</li></ol></li></ul><h2 id="接口-interface"><a href="#接口-interface" class="headerlink" title="接口(interface)"></a>接口(interface)</h2><p>接口与类是同一级的，类用class定义，接口用interface定义，二者之间是实现implements的关系</p><p>可以粗略理解为：抽象更多描述的是事物；接口描述的是一种规则，更多描述的是行为.</p><p>关键字interface写在权限修饰符之后</p><ul><li><p>接口不能实例化</p></li><li><p>接口与类之间是实现关系，通过implements关键字表示</p><p>public class 类名 implements 接口名 { }</p></li><li><p>接口的子类(实现类)：</p><ol><li>要么重写接口中的所由抽象方法</li><li>要么是抽象类</li></ol><p>接口与类的实现关系，可以单实现，也可以多实现</p><p>public class 类名 implements 接口1，接口2 { }</p></li></ul><h3 id="接口中成员的特点"><a href="#接口中成员的特点" class="headerlink" title="接口中成员的特点"></a>接口中成员的特点</h3><ul><li>成员变量：只能是常量，默认修饰符public static final</li><li>构造方法：没有</li><li>成员方法：只能是抽象方法，默认修饰符public static final</li></ul><h3 id="接口与类之间的关系"><a href="#接口与类之间的关系" class="headerlink" title="接口与类之间的关系"></a>接口与类之间的关系</h3><ul><li>类与类的关系：继承关系，只能单继承，不能多继承，但可以多层击沉</li><li>类与接口的关系：实现关系，可以单实现也可以多实现，还可以在继承一个类的同时实现多个接口</li><li>接口与接口的关系：继承关系，可以单继承，也可以多继承</li></ul><h3 id="接口多态"><a href="#接口多态" class="headerlink" title="接口多态"></a>接口多态</h3><p>​    是指当一个方法的参数是接口时，可以传递接口所有实现类的对象</p><h3 id="JKD8以后接口中的新特性"><a href="#JKD8以后接口中的新特性" class="headerlink" title="JKD8以后接口中的新特性"></a>JKD8以后接口中的新特性</h3><ul><li>默认方法</li><li>静态方法</li><li>私有方法 —- &gt; jkd9以后出现</li></ul><h3 id="适配器设计模式"><a href="#适配器设计模式" class="headerlink" title="适配器设计模式"></a>适配器设计模式</h3><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><ul><li>内部类可以直接访问外部类的成员，包括私有</li><li>外部类要访问内部类的成员，必须创建对象（在外部类的方法中直接创建内部类的对象,然后访问）</li></ul><h3 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h3><ul><li><p>成员内部类可以被一些修饰符所修饰，效果与普通类一样</p></li><li><p>获取成员内部类的方法：1.外部类提供内部类对象的方法；2.外部类.内部类 对象名 = 外部类对象.内部类对象</p><p>Outer.Inner oi = new Outer( ). new Inner( );</p></li></ul><h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><p>静态内部类只能访问外部类中的静态变量与静态方法，如果想访问非静态的需要创建对象</p><p>创建静态内部类对象的格式： 外部类名.内部类名 对象名 = new 外部类名.内部类名( )</p><p>调用非静态方法的格式：先创建对象，用对象调用</p><h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h3><p>将内部类定义在方法里面，类似于方法中的变量</p><p>外界无法直接使用，需要在方法内部创建对象并使用</p><p>该类可以直接访问外部类的成员，也可以访问方法内的局部变量</p><h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>隐藏了名称的内部类</p><p>定义方式:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> 类名/接口名&#123;</span><br><span class="line">重写方法;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>整体是一个类的子类或接口的实现类对象</p><h2 id="Object-与-Objects类"><a href="#Object-与-Objects类" class="headerlink" title="Object 与 Objects类"></a>Object 与 Objects类</h2><h3 id="Object类中的方法"><a href="#Object类中的方法" class="headerlink" title="Object类中的方法"></a>Object类中的方法</h3><ol><li><p>toString( )方法</p></li><li><p>equals( )方法</p><ul><li>String类中的equals( )方法首先判断参数是否为字符串，如果是再比较内部的属性值，但如果不是，则直接返回false</li><li>StringBuulder类中没有equals( )方法，因此它会继承父类Object中的equals( )方法，直接比较两个对象的地址值</li></ul></li><li><p>clone( )方法</p><p>书写细节：重写Object类中的clone( )方法，让javabean类实现Cloneable接口，创建原对象并调用clone( )</p><ul><li><strong>浅克隆/浅拷贝</strong>(Object中的克隆)：不管对象内部的属性是基本数据类型还是引用数据类型，都完全拷贝过来</li><li><strong>深克隆/深拷贝：</strong>基本数据类型拷贝过来，字符串复用串池中的字符串，引用数据类型会在堆中重新创建新的</li></ul></li></ol><h3 id="Objects类"><a href="#Objects类" class="headerlink" title="Objects类"></a>Objects类</h3><p>Objects是一个工具类，提供了一些方法去完成一些功能</p><ol><li>equals( )方法：先做非空判断，再比较两个对象</li><li>isNull( )方法：判断对象是否为null</li><li>nonNull( )方法：判断对象是否不为null</li></ol><h2 id="BigInteger"><a href="#BigInteger" class="headerlink" title="BigInteger"></a>BigInteger</h2><p>对象一旦创建,内部的数据不能发生改变</p><p>只要进行计算都会产生一个新的BigInteger对象</p><ol><li>public BigInteger(int num, Random rnd)  获取随即的大整数，范围[0 ~ 2的num次方 - 1]</li><li>public BigInteger(String val)  获取指定的大整数，val必须为整数</li><li>public BigInteger(String val, int radix)  获取指定进制的大整数</li><li>public static BigInteger valueof(long val) 静态方法获取BigInteger对象，-16~16之间有内部优化</li></ol><h3 id="常见方法"><a href="#常见方法" class="headerlink" title="常见方法"></a>常见方法</h3><p>add, substract, nultiply, divide ……</p><h3 id="BigInteger底层原理"><a href="#BigInteger底层原理" class="headerlink" title="BigInteger底层原理"></a>BigInteger底层原理</h3><h2 id="BigDecima"><a href="#BigDecima" class="headerlink" title="BigDecima"></a>BigDecima</h2><p>解决小数在计算机中运算精度的问题 —————— 涉及小数在计算机底层的存储原理 IEEE </p><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>用于校验字符串是否满足一定规则</p><p>在一段文本中查找满足要求的内容</p><p><strong>调用方法：</strong> String对象名.matches(正则表达式);</p><h3 id="语法规则："><a href="#语法规则：" class="headerlink" title="语法规则："></a>语法规则：<img src="C:\Users\wilbur\Documents\WeChat Files\wxid_v5h1rlf6c62222\FileStorage\Temp\a0e51ee74860a39278f607f930fe03e.jpg" alt="a0e51ee74860a39278f607f930fe03e"></h3><p>Pattern类：表示正则表达式</p><p>Matcher类：文本匹配器，作用为按照正则表达式的规则去读取字符串，从头开始读取，在大串中招符合匹配规则的子串</p><h3 id="爬取文本中满足要求的内容"><a href="#爬取文本中满足要求的内容" class="headerlink" title="爬取文本中满足要求的内容"></a>爬取文本中满足要求的内容</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Java自从95年问世以来，经历了很多版本，目前企业中用的最多的是Java8和Java11，因为这两个是长期支持版本，下一个长期支持版本是Java17,相信在未来不久Java17也会逐渐登上历史舞台&quot;</span></span><br><span class="line"><span class="comment">// 找出里面所有的Java**</span></span><br><span class="line"><span class="type">Pattern</span> <span class="variable">p</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;Java\\d&#123;0,2&#125;&quot;</span>);   <span class="comment">//获取正则表达式对象</span></span><br><span class="line"><span class="type">Matcher</span> <span class="variable">m</span> <span class="operator">=</span> p.matcher(str);                    <span class="comment">//获取文本匹配器对象</span></span><br><span class="line"><span class="keyword">while</span>(m.find())&#123; <span class="comment">//find()方法，如果没有返回false,否则返回true，在底层记录子串的 起始索引 和  结束索引+1</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> m.group();<span class="comment">//group方法会根据find()方法记录的所有进行字符串的截取，截取的小串返回</span></span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="时间类"><a href="#时间类" class="headerlink" title="时间类"></a>时间类</h2><h3 id="Date类"><a href="#Date类" class="headerlink" title="Date类"></a>Date类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Date</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> time; <span class="comment">//当前时间的毫秒值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Date</span><span class="params">()</span>&#123;<span class="built_in">this</span>.time = System.currentTimeMillis(); &#125; <span class="comment">//空参构造</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Date</span><span class="params">(<span class="type">long</span> time)</span>&#123;<span class="built_in">this</span>.time = time&#125;                <span class="comment">//带参构造</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getTime</span><span class="params">()</span>&#123;<span class="keyword">return</span> time&#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTime</span><span class="params">(<span class="type">long</span> time)</span>&#123; <span class="built_in">this</span>.time = time&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SimpleDateFormat类"><a href="#SimpleDateFormat类" class="headerlink" title="SimpleDateFormat类"></a>SimpleDateFormat类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">SimpleDateFormat</span><span class="params">()</span>                      <span class="comment">//默认格式</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">SimpleDateFormat</span><span class="params">(String pattern)</span>        <span class="comment">//指定格式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//常用方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">format</span><span class="params">(Date date)</span>           <span class="comment">//格式化(日期对象-&gt;字符串)</span></span><br><span class="line"><span class="keyword">public</span> Date <span class="title function_">parse</span><span class="params">(String source)</span>                <span class="comment">//解析(字符串-&gt;日期对象)</span></span><br></pre></td></tr></table></figure><h3 id="Calendar类"><a href="#Calendar类" class="headerlink" title="Calendar类"></a>Calendar类</h3><ul><li>Calendar类是一个抽象类，需要用getInstance( )方法获取其子类对象</li><li>月份：范围0~11； 星期：(日，一，二，三，四，五，六)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Date <span class="title function_">getTime</span><span class="params">()</span>;       <span class="comment">//获取日期对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="title function_">setTime</span><span class="params">(Date date)</span>;   <span class="comment">//给日历设置日期对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getTimeInMillis</span><span class="params">()</span>;     <span class="comment">//拿到时间毫秒值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTimeInMillis</span><span class="params">(<span class="type">long</span> millis)</span>; <span class="comment">//给日历设置时间毫秒值</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> field)</span>;         <span class="comment">//取日历中的某个字段信息</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(<span class="type">int</span> field, <span class="type">int</span> value)</span>;<span class="comment">//修改日历的某个字段的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> field, <span class="type">int</span> amount)</span>;<span class="comment">//为某个字段增加/减少值</span></span><br></pre></td></tr></table></figure><h3 id="ZoneId类"><a href="#ZoneId类" class="headerlink" title="ZoneId类"></a>ZoneId类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Set&lt;String&gt; <span class="title function_">getAvailableZoneIds</span><span class="params">()</span>; <span class="comment">//获取Java中支持的所有时区</span></span><br><span class="line"><span class="keyword">static</span> ZoneId <span class="title function_">systemDefault</span><span class="params">()</span>;            <span class="comment">//获取系统默认时区</span></span><br><span class="line"><span class="keyword">static</span> ZoneId <span class="title function_">of</span><span class="params">(String zoneId)</span>;          <span class="comment">//获取一个指定时区</span></span><br></pre></td></tr></table></figure><p>Instant时间戳类/ ZoneDateTime带时区的时间类/ LocalDate/ LocalTime/ LocalDateTime….</p><h3 id="时间工具类"><a href="#时间工具类" class="headerlink" title="时间工具类"></a>时间工具类</h3><p>Duration时间间隔类 / Period类 / ChronoUnit时间间隔</p><h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><p>基本数据类型对应的引用类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自动装箱</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;    <span class="comment">//在底层，还是会调用valueof得到一个Integer对象</span></span><br><span class="line"><span class="comment">//自动拆箱</span></span><br><span class="line"><span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;</span><br></pre></td></tr></table></figure><h2 id="Arrays工具类"><a href="#Arrays工具类" class="headerlink" title="Arrays工具类"></a>Arrays工具类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">toString</span><span class="params">(数组)</span>;       <span class="comment">//将数组拼接为一个字符串</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(数组，查找的元素)</span>; <span class="comment">//二分查找法查找元素</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] copyOf(数组，数组长度); <span class="comment">//拷贝数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] copyOfRange(原数组，起始索引，结束索引); <span class="comment">//拷贝指定范围数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> viod <span class="title function_">fill</span><span class="params">(数组，元素)</span>; <span class="comment">//用元素填充数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(数组)</span>; <span class="comment">//按默认方式(升序)对数组进行排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(数组，排序规则)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">sort()底层原理：</span></span><br><span class="line"><span class="comment">·利用插入排序+二分查找的方式进行排序</span></span><br><span class="line"><span class="comment">·默认把0索引的数据当作是有序序列，1索引到最后的默认为无序序列</span></span><br><span class="line"><span class="comment">·遍历无序序列得到里面的每一个元素，假设当前为A</span></span><br><span class="line"><span class="comment">·把A往有序序列中进行插入，再插入时，是利用二分查找确定A的插入点</span></span><br><span class="line"><span class="comment">·拿着A元素，跟插入点的元素进行比较，比较的规则就是compare方法的方法体</span></span><br><span class="line"><span class="comment">·返回值为负数，拿着A继续与前面的元素比较</span></span><br><span class="line"><span class="comment">·返回值为非负数，拿着A继续与后面的元素比较，直到确定A的最终位置</span></span><br><span class="line"><span class="comment">排序规则：</span></span><br><span class="line"><span class="comment">1. 只能给引用数据类型的数组进行排序,如果待排序数组是基本数据类型的，需要变成对应的包装类数组</span></span><br><span class="line"><span class="comment">2. 排序规则是一个接口，因此调用该方法时需要传入其实现类对象，一般采取匿名内部类的方式</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">() -&gt; &#123;&#125; <span class="comment">// ()对应形参，&#123;&#125;对应方法体</span></span><br></pre></td></tr></table></figure><ul><li>Lambda表达式可以用来简化匿名内部类的书写</li><li>Lambda表达式只能简化函数式接口的匿名内部类的写法</li><li>函数式接口：有且仅有一个抽象方法的接口。接口上方可以加  @FunctionalInterface注解</li></ul><h3 id="省略规则"><a href="#省略规则" class="headerlink" title="省略规则"></a>省略规则</h3><ul><li>参数类型可以不写</li><li>如果只有一个参数，参数类型可以省略，( )可以省略</li><li>如果Lambda表达式的方法体只有一个，可以同时省去{ }, return, ; 。</li></ul><h1 id="集合体系结构"><a href="#集合体系结构" class="headerlink" title="集合体系结构"></a>集合体系结构</h1><h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><p><img src="C:\Users\wilbur\Documents\WeChat Files\wxid_v5h1rlf6c62222\FileStorage\Temp\61852b6212e8d66365b8d2dd814e0d2.jpg" alt="61852b6212e8d66365b8d2dd814e0d2" style="zoom:50%;" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span>;                <span class="comment">//添加对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span>;                    <span class="comment">//清空元素</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(E e)</span>;             <span class="comment">//删除指定对象</span></span><br><span class="line"><span class="comment">//contains方法底层是调用的父类的equals方法，如果集合中存储的为自定义对象(引用数据类型),则需要重写equals方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object obj)</span>;    <span class="comment">//判断是否包含obj </span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>;               <span class="comment">//判空</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>;                      <span class="comment">//集合大小</span></span><br></pre></td></tr></table></figure><h3 id="遍历方式"><a href="#遍历方式" class="headerlink" title="遍历方式"></a>遍历方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;String&gt; coll = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// 迭代器遍历</span></span><br><span class="line">Iterator&lt;String&gt; it = coll.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNest())&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> it.next();</span><br><span class="line">    System.out.println(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//增强for遍历 ------- 只能用于所有单列集合和数组</span></span><br><span class="line"><span class="comment">//修改遍历变量，不会使集合中的数据</span></span><br><span class="line"><span class="keyword">for</span>(String str : coll)&#123;</span><br><span class="line">    System.out.println(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Lambda表达式遍历</span></span><br><span class="line">coll.forEach(s -&gt; System.out.println(s));</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E emelent)</span>;       <span class="comment">//在指定位置插入元素</span></span><br><span class="line">E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span>;                  <span class="comment">//在指定位置删除元素，并将该元素返回</span></span><br><span class="line">E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E element)</span>;          <span class="comment">//修改指定位置的元素，返回被修改的元素</span></span><br><span class="line">E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span>;                     <span class="comment">//获取指定位置的元素</span></span><br></pre></td></tr></table></figure><h4 id="遍历方式-1"><a href="#遍历方式-1" class="headerlink" title="遍历方式"></a>遍历方式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayLisy</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//Collection中的三种遍历方式List均可以复用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//4.普通for循环</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;list.size(); i++)&#123;</span><br><span class="line">    System.out.println(list.get(i));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//列表迭代器ListIterator：遍历时可以添加元素</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="ArrayList源码分析"><a href="#ArrayList源码分析" class="headerlink" title="ArrayList源码分析"></a>ArrayList源码分析</h2><p><img src="C:\Users\wilbur\AppData\Roaming\Typora\typora-user-images\image-20240709172613953.png" alt="image-20240709172613953" style="zoom: 50%;" /></p><h3 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h3><ul><li>利用空参创建的集合，在底层最开始创建一个默认长度为0的名为elementData的数组</li><li>添加第一个元素时，底层会创建一个新的长度为10的数组</li><li>存满时，扩容1.5倍</li><li>如果一次添加多个元素，1.5倍放不下，则新创建数组的长度以实际为准</li></ul><h2 id="LinkedList底层源码"><a href="#LinkedList底层源码" class="headerlink" title="LinkedList底层源码"></a>LinkedList底层源码</h2><p><img src="C:\Users\wilbur\AppData\Roaming\Typora\typora-user-images\image-20240710143823305.png" alt="image-20240710143823305"></p><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>可以在编译阶段约束操作的数据类型，格式&lt;数据类型&gt;，但只支持引用数据类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//没有泛型时</span></span><br><span class="line"><span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();      <span class="comment">//没有泛型的集合</span></span><br><span class="line">list.add(<span class="number">123</span>); <span class="comment">//装箱为Integer</span></span><br><span class="line">list.add(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">list.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">22</span>));     <span class="comment">//可以添加任意引用数据类型</span></span><br><span class="line"><span class="comment">//但是在遍历时，迭代器对象为Object类型，多态下父类对象不能访问子类特有的方法</span></span><br></pre></td></tr></table></figure><p>Java中的泛型是伪泛型，只在编译期间起作用，数据在集合中真正仍为Object对象</p><p>在编译结束的class文件中，泛型全部被擦除，称为泛型擦除</p><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当一个类中，某个变量的数据类型不确定时，就可以定义带有泛型的类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt;&#123; &#125;</span><br></pre></td></tr></table></figure><h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当方法中形参类型不确定时，可以使用类名后定义的泛型&lt;E&gt;， 也可以在方法申明上定义自己的泛型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//方法一：在类中的所有方法均可以使用泛型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt;&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">get</span><span class="params">(E e)</span>&#123;</span><br><span class="line">        system.out.println(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法二：仅在本方法中可以使用泛型</span></span><br><span class="line"><span class="keyword">public</span>&lt;T&gt; <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(T t)</span>&#123; &#125;;</span><br></pre></td></tr></table></figure><h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//与泛型类相似</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">List</span>&lt;E&gt;&#123;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用方式</span></span><br><span class="line"><span class="comment">//1.实现类给出具体类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1</span> inplements List&lt;String&gt;&#123;</span><br><span class="line">    <span class="comment">//重写List接口中的所有抽象方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.实现类延续泛型，创建对象时在确定类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo2</span> inolements List&lt;E&gt;&#123;</span><br><span class="line">    <span class="comment">//重写List接口中的所有抽象方法</span></span><br><span class="line">&#125;</span><br><span class="line">Demo2&lt;String&gt; arr = <span class="keyword">new</span> <span class="title class_">Demo2</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><h3 id="泛型的继承与通配符"><a href="#泛型的继承与通配符" class="headerlink" title="泛型的继承与通配符"></a>泛型的继承与通配符</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//泛型不具备继承性，但是数据具备继承性</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ye</span>&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fu</span> <span class="keyword">extends</span> <span class="title class_">Ye</span>&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Zi</span> <span class="keyword">extends</span> <span class="title class_">Fu</span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(ArratList&lt;Ye&gt; list)</span>&#123;&#125;</span><br><span class="line">    ArrayList&lt;Ye&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    ArrayList&lt;Fu&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    ArrayList&lt;Zi&gt; list3 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//泛型不具备继承多态性,调用method方法时必须传递相应类型的参数</span></span><br><span class="line">    method(list1);</span><br><span class="line">    method(liest2);<span class="comment">//报错</span></span><br><span class="line">    method(list3);<span class="comment">//报错</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//数据具备继承与多态性</span></span><br><span class="line">    list1.add(<span class="keyword">new</span> <span class="title class_">Ye</span>());</span><br><span class="line">    list1.add(<span class="keyword">new</span> <span class="title class_">Fu</span>());</span><br><span class="line">    list1.add(<span class="keyword">new</span> <span class="title class_">Zi</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通配符?</span></span><br><span class="line"><span class="comment">// ? extends E:表示可以传递E或者E所有子类类型</span></span><br><span class="line"><span class="comment">// ? super E:表示可以传递E或者E所有父类类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">(ArratList&lt;? extends Ye&gt; list)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">(ArratList&lt;? <span class="built_in">super</span> Zi&gt; list)</span>&#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><ul><li>无序：存取顺序不一致</li><li>不重复：可以去除重复</li><li>无索引：没有带索引的方法，不能用for循环来遍历，也不能通过[ ]索引来获取元素</li><li>Set是一个接口，其中的方法与Collection的API一致</li></ul><h2 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//哈希值：根据hashCode方法计算v胡来的int类型的整数</span></span><br><span class="line"><span class="comment">//该方法定义在Object类中，所有对象都可以调用，默认使用地址值计算</span></span><br></pre></td></tr></table></figure><h3 id="哈希值的特点"><a href="#哈希值的特点" class="headerlink" title="哈希值的特点"></a>哈希值的特点</h3><ul><li>如果没有重写hashCode方法，不同对象计算出的哈希值时不同的</li><li>重写了hashCode后，只要对象的属性值一样则哈希值也一样( ALT + INSERT快捷键)</li><li>在部分情况下，不同属性值或者不同地址值计算出的哈希值一样，称为哈希冲突</li></ul><h3 id="HashSet底层原理"><a href="#HashSet底层原理" class="headerlink" title="HashSet底层原理"></a>HashSet底层原理</h3><ul><li>HashSet集合底层采取哈希表存储数据</li><li>JDK8以前哈希表由数组+链表组成</li><li>JDK8开始哈希表由数组+链表+红黑树组成</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.创建一个默认长度为16，默认加载因子为0.75的数组，数组名为table</span><br><span class="line">2.根据元素的哈希值跟数组的长度计算出应存入的位置：int index = (数组长度-1) &amp; 哈希值</span><br><span class="line">3.判断当前位置是否为null，如果是null直接存入</span><br><span class="line">4.否则调用equals方法比较属性值</span><br><span class="line">5.一样：不存；不一样：存入数组，形成链表</span><br><span class="line">JDK8以前：老元素挂到新元素下面   JDK8以后：新元素挂到老元素下面</span><br><span class="line"></span><br><span class="line">JDK8以后，当链表长度超过8，且数组长度≥64时，链表自动转换为红黑树</span><br><span class="line">如果集合中存储的是自定义对象，必须重写equals方法和hashCode方法</span><br></pre></td></tr></table></figure><h2 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h2><p>底层基于哈希表，但是使用双链表记录添加顺序</p><h2 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h2><p>元素不重复，无索引，可排序。底层采用红黑树实现</p><h3 id="比较规则："><a href="#比较规则：" class="headerlink" title="比较规则："></a>比较规则：</h3><ul><li>自然排序/默认排序：默认按升序排序；如果TreeSet中存储的元素为自定义对象，需要在JavaBean类中实现Comparable接口指定比较规则</li><li>比较器排序：创建TressSet时，传递比较器Comparator指定规则(利用带参构造传入匿名的Comparator对象)</li></ul><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p><img src="C:\Users\wilbur\AppData\Roaming\Typora\typora-user-images\image-20240712142909097.png" alt="image-20240712142909097"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//常用方法</span></span><br><span class="line">V <span class="title function_">put</span><span class="params">(K key, V value)</span>;              <span class="comment">//添加(覆盖)元素，如果键存在，会覆盖原有键值对，并返回被覆盖的值</span></span><br><span class="line">V <span class="title function_">remove</span><span class="params">(Object key)</span>;               <span class="comment">//根据键删除键值对元素，并返回被删除的值</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span>;                       <span class="comment">//移除所有键值对元素</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">containsKey</span><span class="params">(Object key)</span>;    <span class="comment">//判断集合是否包含指定的键</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">containsValue</span><span class="params">(Object value)</span>;<span class="comment">//判断集合是否包含指定的值</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>;                  <span class="comment">//判空</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>;                         <span class="comment">//计算集合中键值对的个数</span></span><br></pre></td></tr></table></figure><h3 id="遍历方式-2"><a href="#遍历方式-2" class="headerlink" title="遍历方式"></a>遍历方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">map.put(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">22</span>);</span><br><span class="line">map.put(<span class="string">&quot;lsi&quot;</span>, <span class="number">23</span>);</span><br><span class="line">map.put(<span class="string">&quot;wangwu&quot;</span>, <span class="number">24</span>);</span><br><span class="line"><span class="comment">//方法一：获取所有的键，将这些键放在一个单列集合中,遍历每一个键，使用get()得到值</span></span><br><span class="line">Set&lt;String&gt; keys = map.keySet();</span><br><span class="line"><span class="keyword">for</span>(String key:keys)&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法二：通过键值对对象进行遍历，遍历entries集合，获得每一个键值对对象</span></span><br><span class="line">Set&lt;Map.Entry&lt;String, Integer&gt;&gt; entries = map.entrySet();</span><br><span class="line"><span class="keyword">for</span>(Map.Entry&lt;String, Integer&gt; entry : entries)&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">    <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法三：Lambda表达式遍历</span></span><br><span class="line"><span class="comment">//底层原理：利用第二种方法，得到键值对对象，然后调用accept()方法</span></span><br><span class="line">map.forEach((key,value)-&gt;System.out.println(key + <span class="string">&quot;=&quot;</span> + value));</span><br></pre></td></tr></table></figure><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol><li>HashMap底层时哈希表结构</li><li>依赖HashCode( )和equals( )保证键的唯一</li><li>如果键存储的是自定义对象，需要重写HashCode方法和equals方法</li></ol><h2 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h2><ul><li>由键决定：有序，不重复，无索引</li><li>这里的有序指的是存储和取出的元素顺序一致</li><li>原理：底层数据结构仍未哈希表，只是每个键值对元素又额外多了一个双链表的机制记录存储顺序</li></ul><h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><ul><li>TreeMap与TreeSet底层原理一样，也是由红黑树构成的</li><li>由键决定 ：不重复，无索引，可排序，可排序指的是可以根据键进行排序</li><li>与TreeSet一样，可以自己定义比较规则</li></ul><h2 id="HashMap-与-TreeMap底层源码分析"><a href="#HashMap-与-TreeMap底层源码分析" class="headerlink" title="HashMap 与 TreeMap底层源码分析"></a>HashMap 与 TreeMap底层源码分析</h2><h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//格式   属性类型...名字</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getSum</span><span class="params">(<span class="type">int</span>...args)</span>&#123;</span><br><span class="line"><span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> a:args)sum += a;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在方法的形参中最多只能有一个可变参数</span></span><br><span class="line"><span class="comment">//在方法中，如果除了可变参数以外还有其他的形参，可变参数必须放在最后面</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h2><p>集合的工具类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(Collection&lt;T&gt; c, T...elements)</span>;              <span class="comment">//批量添加元素到c中</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">shuffle</span><span class="params">(List&lt;?&gt; list)</span>;                                     <span class="comment">//打乱List集合元素的顺序</span></span><br><span class="line"></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">Collections.addAll(list, <span class="string">&quot;abc&quot;</span>,<span class="string">&quot;bcd&quot;</span>. <span class="string">&quot;qwer&quot;</span>);</span><br><span class="line">Collections.shuffle(list);</span><br></pre></td></tr></table></figure><h2 id="不可变集合"><a href="#不可变集合" class="headerlink" title="不可变集合"></a>不可变集合</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = List.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line">Set&lt;Integer&gt; set = Set.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line"><span class="comment">//Map的不可变集合中最多存储10对键值对,如果要传递多个键值对(&gt;10)，必须传递entry对象;很复杂。。。</span></span><br><span class="line">Map&lt;Integer,String&gt; map = Map.of(<span class="number">1</span>,<span class="string">&quot;李震&quot;</span>,<span class="number">2</span>,<span class="string">&quot;冯鼎智&quot;</span>,<span class="number">3</span>,<span class="string">&quot;卢艺丰&quot;</span>,<span class="number">4</span>,<span class="string">&quot;叶文杰&quot;</span>);</span><br><span class="line">Set&lt;Map.Entry&lt;Integer,String&gt;&gt; entries = map.entrySet();</span><br><span class="line">Map.Entry[] arr1 = <span class="keyword">new</span> <span class="title class_">Map</span>.Entry[<span class="number">0</span>];</span><br><span class="line">Map.Entry[] arr2 = entries.toArray(arr1);</span><br><span class="line"><span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> Map.ofEntries(arr2);</span><br></pre></td></tr></table></figure><h1 id="Stream流"><a href="#Stream流" class="headerlink" title="Stream流"></a>Stream流</h1><p><img src="C:\Users\wilbur\AppData\Roaming\Typora\typora-user-images\image-20240713153322162.png" alt="image-20240713153322162"></p><p>注意：对于Stream接口的中 of 静态方法，传入数组时。若数组的数据类型为基本数据类型，则只会被当成一个元素(数组的地址)存储到Stream中。因此使用该方法时，必须保证of方法里传入的数组类型为引用数据类型</p><h2 id="Stream流的中间方法"><a href="#Stream流的中间方法" class="headerlink" title="Stream流的中间方法"></a>Stream流的中间方法</h2><p><img src="C:\Users\wilbur\AppData\Roaming\Typora\typora-user-images\image-20240713154532833.png" alt="image-20240713154532833" style="zoom:50%;" /></p><p>注意：</p><ul><li>使用distinct方法去重时，如果是对引用数据类型去重，则在类里面一定要重写hashCode方法和equals方法</li><li>使用concat方法合并两个流对象时，若两个流的对象类型不一样，则合并后的类型为两个对象最近的父类对象，因此在使用concat方法时，尽量保证两个流中数据类型一致</li><li>map方法形参中的Function接口中第一个参数为流中原本的数据类型，第二个为需要转换的数据类型(也只能是引用数据类型)</li></ul><h2 id="Stream流的终结方法"><a href="#Stream流的终结方法" class="headerlink" title="Stream流的终结方法"></a>Stream流的终结方法</h2><p><img src="C:\Users\wilbur\AppData\Roaming\Typora\typora-user-images\image-20240713160254757.png" alt="image-20240713160254757"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//toArray()方法</span></span><br><span class="line"><span class="type">String</span> <span class="variable">arr</span> <span class="operator">=</span> list.stream().toArray(<span class="keyword">new</span> <span class="title class_">IntFunction</span>&lt;String[]&gt;)&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] apply(<span class="type">int</span> value)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[value];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Lambda表达式：String arr = list.stream().toArray(value-&gt;new String[value]);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//collet()方法</span></span><br><span class="line">List&lt;String&gt; newlist1=list.stream()</span><br><span class="line">    .filter(s-&gt;<span class="string">&quot;男&quot;</span>.equals(s.split(<span class="string">&quot;-&quot;</span>)[<span class="number">1</span>]))</span><br><span class="line">                               .collect(Collectors.toList());</span><br><span class="line">Set&lt;String&gt; newlist2=list.stream()</span><br><span class="line">    .filter(s-&gt;<span class="string">&quot;男&quot;</span>.equals(s.split(<span class="string">&quot;-&quot;</span>)[<span class="number">1</span>]))</span><br><span class="line">                               .collect(Collectors.toSet());</span><br><span class="line"><span class="comment">//toMap():参数一表示键的生成规则，参数二表示值的生成规则,且键不能重复</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数一：</span></span><br><span class="line"><span class="comment">Function泛型一：表示流中的每一个数据的类型</span></span><br><span class="line"><span class="comment">    泛型二：表示Map集合中键的数据类型</span></span><br><span class="line"><span class="comment"> 方法apply形参：依次表示流中的每个数据</span></span><br><span class="line"><span class="comment"> 方法体：生成键的代码</span></span><br><span class="line"><span class="comment"> 返回值：已经生成的键</span></span><br><span class="line"><span class="comment">参数二：</span></span><br><span class="line"><span class="comment">Function泛型一：表示流中的每一个数据的类型</span></span><br><span class="line"><span class="comment">    泛型二：表示Map集合中值的数据类型</span></span><br><span class="line"><span class="comment"> 方法apply形参：依次表示流中的每个数据</span></span><br><span class="line"><span class="comment"> 方法体：生成值的代码</span></span><br><span class="line"><span class="comment"> 返回值：已经生成的值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Map&lt;String, Integer&gt; map = list.stream()</span><br><span class="line">     .filter(s-&gt;<span class="string">&quot;男&quot;</span>.equals(s.split(<span class="string">&quot;-&quot;</span>)[<span class="number">1</span>]))</span><br><span class="line">     .collect(Collectors.toMap(<span class="keyword">new</span> <span class="title class_">Function</span>&lt;String,Integer&gt;()&#123;</span><br><span class="line">                                 <span class="meta">@Override</span></span><br><span class="line">                                 <span class="keyword">public</span> String <span class="title function_">apply</span><span class="params">(String s)</span>&#123;</span><br><span class="line">                                     <span class="keyword">return</span> s.splite(<span class="string">&quot;-&quot;</span>)[<span class="number">0</span>];</span><br><span class="line">                                 &#125;</span><br><span class="line">                             &#125;,</span><br><span class="line">                                                      <span class="keyword">new</span> <span class="title class_">Function</span>&lt;String,Integer&gt;()&#123;</span><br><span class="line">                                                          <span class="meta">@Override</span></span><br><span class="line">                                                          <span class="keyword">public</span> String <span class="title function_">apply</span><span class="params">(String s)</span>&#123;</span><br><span class="line">                                                              <span class="keyword">return</span> Integer.parseInt(s.splite(<span class="string">&quot;-&quot;</span>)[<span class="number">2</span>]);</span><br><span class="line">                                                          &#125;</span><br><span class="line">                                                      &#125;))</span><br></pre></td></tr></table></figure><h2 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h2><ol><li>需要有函数式接口</li><li>被引用的方法必须存在</li><li>方法的形参和返回值需要与抽象方法/接口的形参与返回值一样</li><li>被引用方法的功能需要满足当前的需求</li></ol><ul><li>引用静态方法</li><li>引用成员方法</li><li>引用构造方法</li><li>引用其他的方法</li></ul><h3 id="引用静态方法"><a href="#引用静态方法" class="headerlink" title="引用静态方法"></a>引用静态方法</h3><p>类名::静态方法名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例子：集合中有字符串1，2，3，4，5要求将他们变为int类型</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">Collections.addAll(list,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;3&quot;</span>,<span class="string">&quot;4&quot;</span>,<span class="string">&quot;5&quot;</span>);</span><br><span class="line">list.stream().map(<span class="keyword">new</span> <span class="title class_">Function</span>&lt;String,Integer&gt;()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="type">int</span> i=Integer.parseInt(s);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;).forEach(s -&gt; system.out.println(s));</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法引用</span></span><br><span class="line">list.stream().map(Integer::parseInt).forEach(s -&gt; system.out.println(s));</span><br></pre></td></tr></table></figure><h3 id="引用成员方法"><a href="#引用成员方法" class="headerlink" title="引用成员方法"></a>引用成员方法</h3><p>对象::成员方法</p><ul><li>其他类：其它类对象::方法名</li><li>本类：this::方法名</li><li>父类：super:方法名</li></ul><h3 id="引用构造方法"><a href="#引用构造方法" class="headerlink" title="引用构造方法"></a>引用构造方法</h3><p>类名::new</p><h3 id="其他引用方法"><a href="#其他引用方法" class="headerlink" title="其他引用方法"></a>其他引用方法</h3><ul><li>类名引用成员方法：类名：方法名  eg. String::toUpperCase</li><li>引用数组的构造方法：数据类型[]::new   eg.int[ ]::new</li></ul><h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><p><img src="C:\Users\wilbur\AppData\Roaming\Typora\typora-user-images\image-20240714152409990.png" alt="image-20240714152409990"></p><h2 id="异常的作用"><a href="#异常的作用" class="headerlink" title="异常的作用"></a>异常的作用</h2><ol><li>查询相关bug的关键参考信息</li><li>异常可以作为方法内部的一种特殊返回值，以便通知调用者底层的执行情况</li></ol><h2 id="JVM默认的处理方式"><a href="#JVM默认的处理方式" class="headerlink" title="JVM默认的处理方式"></a>JVM默认的处理方式</h2><ul><li>把异常的名称，异常原因以及异常出现的位置等信息输出在控制台</li><li>程序停止执行，下面的代码不会继续执行</li></ul><h2 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//可能出现异常的代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类名 变量名)&#123;</span><br><span class="line">   <span class="comment">// 异常处理的代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//catch之后的代码也会被执行</span></span><br></pre></td></tr></table></figure><h3 id="如果try中出现了多个问题，如何执行？"><a href="#如果try中出现了多个问题，如何执行？" class="headerlink" title="如果try中出现了多个问题，如何执行？"></a>如果try中出现了多个问题，如何执行？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    system.out.println(arr[<span class="number">10</span>]);           <span class="comment">//抛出ArrayIndexOutOfBoundsException</span></span><br><span class="line">    system.out.println(<span class="number">10</span> / <span class="number">0</span>);       <span class="comment">//抛出ArithmeticException</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(ArrayIndexOutOfBoundsException e)&#123;</span><br><span class="line">    system.out.println(<span class="string">&quot;数组越界错误&quot;</span>);</span><br><span class="line">&#125;<span class="comment">//catch(ArithmeticException e)&#123;</span></span><br><span class="line"><span class="comment">//system.out.println(&quot;整数除零错误&quot;);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//如果没有写多个catch捕获异常，则在try中出现第一个异常后，下面的代码都不会执行</span></span><br><span class="line"><span class="comment">//如果多个异常存在父子关系，那么父类一定要写在下面</span></span><br></pre></td></tr></table></figure><h3 id="如果try中抛出的-异常没有被catch捕获到，如何执行"><a href="#如果try中抛出的-异常没有被catch捕获到，如何执行" class="headerlink" title="如果try中抛出的 异常没有被catch捕获到，如何执行"></a>如果try中抛出的 异常没有被catch捕获到，如何执行</h3><p>按照JVM的默认方式处理该异常</p><h3 id="如果try中遇到了异常，那么try中该异常下面的代码会执行吗？"><a href="#如果try中遇到了异常，那么try中该异常下面的代码会执行吗？" class="headerlink" title="如果try中遇到了异常，那么try中该异常下面的代码会执行吗？"></a>如果try中遇到了异常，那么try中该异常下面的代码会执行吗？</h3><p>下面的代码不会执行，程序直接跳转到相应的catch中执行，若没有匹配的catch，则默认交给jvm处理</p><h2 id="异常的常见方法"><a href="#异常的常见方法" class="headerlink" title="异常的常见方法"></a>异常的常见方法</h2><p><img src="C:\Users\wilbur\AppData\Roaming\Typora\typora-user-images\image-20240714160941486.png" alt="image-20240714160941486"></p><p>一般只用printStackTrace()方法</p><h2 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//throws:写在方法定义处，告诉调用者，使用该方法可能会出现哪些错误</span></span><br><span class="line"><span class="comment">//throw:写在方法内，结束方法，手动抛出异常，交给调用者，下面的代码不再执行</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getMax</span><span class="params">(<span class="type">int</span>[] arr)</span><span class="comment">/* throws NullPointerException, ArrayIndexOutOfBoundsException */</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr == <span class="literal">null</span>)<span class="keyword">throw</span> NullPointerException();</span><br><span class="line">    <span class="keyword">if</span>(arr.length == <span class="number">0</span>)<span class="keyword">throw</span> ArrayIndexOutOfBoundsException();</span><br><span class="line">    <span class="type">int</span> max=arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i:arr) max = Math.max(max,i);</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span>[] arr = <span class="literal">null</span>;</span><br><span class="line"><span class="type">int</span> max=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    max = getMax(arr);</span><br><span class="line">&#125;<span class="keyword">catch</span>(NullPointerException e)&#123;</span><br><span class="line">    system.out.println(<span class="string">&quot;空指针异常&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span>(ArrayIndexOutOfBoundsException e)&#123;</span><br><span class="line">    system.out.println(<span class="string">&quot;数组越界异常&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">system.out.println(max);</span><br></pre></td></tr></table></figure><h2 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h2><ol><li>定义异常类：类名需要见名知义</li><li>写继承关系：运行时异常继承RunTimeException,否则直接继承Exception</li><li>写空参构造</li><li>写带参构造</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NameFormatException</span> <span class="keyword">extends</span> <span class="title class_">RunTimeException</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NameFormatException</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NameFormatException</span><span class="params">(String message)</span>&#123;</span><br><span class="line">        <span class="comment">//传入的message即为我们想输出在控制台的报错信息</span></span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="File"><a href="#File" class="headerlink" title="File"></a>File</h1><p>File类只能对文件本身进行操作，不能读写文件里面的内容</p><p><img src="C:\Users\wilbur\AppData\Roaming\Typora\typora-user-images\image-20240715140401129.png" alt="image-20240715140401129"></p><p>注意：在路径”C:\Users\Public\Desktop\QQ.lnk”中，父级路径是指C:\Users\Public\Desktop\ 这一部分，子级路径是指 QQ.lnk 这一部分</p><h2 id="File类的常见成员方法"><a href="#File类的常见成员方法" class="headerlink" title="File类的常见成员方法"></a>File类的常见成员方法</h2><p><img src="C:\Users\wilbur\AppData\Roaming\Typora\typora-user-images\image-20240715140850922.png" alt="image-20240715140850922"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意：length()方法只能获取文件的大小，无法获取文件夹的大小</span></span><br></pre></td></tr></table></figure><p><img src="C:\Users\wilbur\AppData\Roaming\Typora\typora-user-images\image-20240715141627358.png" alt="image-20240715141627358"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//createNewFile()方法：如果当前文件路径下不存在该文件，则创建成功。否则，创建失败，父级路径若不存在也会报错IOException</span></span><br><span class="line"><span class="comment">//createNewFile()创建的一定是文件，而不是文件夹</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//windows当中路径是唯一的，如果当前路径已经存在，则无法创建新的文件夹</span></span><br><span class="line"><span class="comment">//mkdir()只能创建单击文件夹，若父级路径中某些文件夹不存在，则会创建失败</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//delete()方法，若删除的是空文件或者空文件夹，则直接删除不走回收站；若删除的是有内容的文件夹，会删除失败</span></span><br></pre></td></tr></table></figure><p><img src="C:\Users\wilbur\AppData\Roaming\Typora\typora-user-images\image-20240715143319175.png" alt="image-20240715143319175"></p><h2 id="获取并遍历的方法"><a href="#获取并遍历的方法" class="headerlink" title="获取并遍历的方法"></a>获取并遍历的方法</h2><p><img src="C:\Users\wilbur\AppData\Roaming\Typora\typora-user-images\image-20240715143429384.png" alt="image-20240715143429384"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//listRoots()只能获取盘符</span></span><br><span class="line">File[] arr = File.listRoots();</span><br><span class="line">System.out.println(arr);     <span class="comment">//打印：[C:\,D:\,E:\]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//list()只能获取当前路径下所有文件和文件夹的名称</span></span><br><span class="line"><span class="type">File</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;路径&quot;</span>);</span><br><span class="line">String[] arr2 = f1.list();</span><br><span class="line"><span class="keyword">for</span>(String s: arr2)System.out.println(s);</span><br></pre></td></tr></table></figure><h1 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h1><p>IO流用于读写文件中的数据，可以读写文件，或者网络中的数据</p><p><img src="C:\Users\wilbur\AppData\Roaming\Typora\typora-user-images\image-20240715151129211.png" alt="image-20240715151129211" style="zoom:50%;" /></p><h2 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h2><p><img src="C:\Users\wilbur\AppData\Roaming\Typora\typora-user-images\image-20240715151306242.png" alt="image-20240715151306242" style="zoom:50%;" /></p><h2 id="FileOutputStream"><a href="#FileOutputStream" class="headerlink" title="FileOutputStream"></a>FileOutputStream</h2><p>操作本地文件的字节输出流，可以把程序中的数据写到本地文件中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//书写步骤</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.创建对象</span></span><br><span class="line"><span class="comment">/*细节1：参数是字符串表示的路径或者是File对象都是可以的</span></span><br><span class="line"><span class="comment"> 细节2：如果文件不存在会创建一个新的空的文件，但要保证其父级路径是存在的</span></span><br><span class="line"><span class="comment"> 细节3：如果文件已经存在，则会清空文件</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;myio\\a.txt&quot;</span>);  </span><br><span class="line"></span><br><span class="line"><span class="comment">//2.写出数据</span></span><br><span class="line"><span class="comment">/*细节1：write方法的参数是整数，但实际上写到本地文件中的是整数在ASCII码上对应的字符</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">fos.write(<span class="number">97</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.释放资源:解除对该文件的占用,每次写完必须释放</span></span><br><span class="line">fos.close();</span><br></pre></td></tr></table></figure><h3 id="FileOutputStream写数据的3中方法"><a href="#FileOutputStream写数据的3中方法" class="headerlink" title="FileOutputStream写数据的3中方法"></a>FileOutputStream写数据的3中方法</h3><p><img src="C:\Users\wilbur\AppData\Roaming\Typora\typora-user-images\image-20240715152657151.png" alt="image-20240715152657151" style="zoom: 67%;" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;myio\\a.txt&quot;</span>);</span><br><span class="line"><span class="comment">//1.方法一</span></span><br><span class="line">fos.write(<span class="number">97</span>);</span><br><span class="line">fos.write(<span class="number">98</span>);</span><br><span class="line"><span class="comment">//方法二</span></span><br><span class="line"><span class="type">byte</span>[] bytes = &#123;<span class="number">97</span>,<span class="number">98</span>,<span class="number">99</span>,<span class="number">100</span>,<span class="number">101</span>&#125;;</span><br><span class="line">fos.write(bytes);</span><br><span class="line"><span class="comment">//方法三</span></span><br><span class="line">fos.write(bytes, <span class="number">1</span>, <span class="number">2</span>);      <span class="comment">//从索引为1的地方开始写入两个字节的数据，结果就是bc</span></span><br><span class="line">fos.close();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//换行写Demo</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">两次写入中间加入一个换行符即可</span></span><br><span class="line"><span class="comment">windows: \r\n</span></span><br><span class="line"><span class="comment">linux:\n</span></span><br><span class="line"><span class="comment">mac:\r</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;myio\\a.txt&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;lizhenhaoshuai&quot;</span>;</span><br><span class="line"><span class="type">byte</span>[] byte1 = str.getBytes();</span><br><span class="line">fos.write(byte1);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">wrap</span> <span class="operator">=</span> <span class="string">&quot;\r\n&quot;</span>;</span><br><span class="line"><span class="type">byte</span>[] wraps = wrap.getBytes();</span><br><span class="line">fos.write(wraps);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;666&quot;</span>;</span><br><span class="line"><span class="type">byte</span>[] byte2 = str.getBytes();</span><br><span class="line">fos.write(byte2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//续写Demo</span></span><br><span class="line"><span class="comment">//创建FileOutputStream对象时，传入true打开续写开关。打开续写开关后，再次写入时，不会清空</span></span><br><span class="line"><span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;myio\\a.txt&quot;</span>, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure><h2 id="FileInputStream"><a href="#FileInputStream" class="headerlink" title="FileInputStream"></a>FileInputStream</h2><p>操作本地文件的字节输入流，可以把本地文件中的数据读取到程序中来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//书写步骤</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.创建对象</span></span><br><span class="line"><span class="comment">//细节1：如果文件不存在，会直接报错</span></span><br><span class="line"></span><br><span class="line"><span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;myio\\a.txt&quot;</span>);  <span class="comment">//假设该文件中的数据为abcde</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.读取数据</span></span><br><span class="line"><span class="comment">/*细节1：read()方法是一字节一字节读取数据，如果读取不到数据了会返回-1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="variable">b1</span> <span class="operator">=</span> fis.read(); <span class="comment">//读取一字节的数据，结果为97(a对应的ASCII码)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3.释放资源:解除对该文件的占用,每次用必须释放</span></span><br><span class="line">fos.close();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//循环读取</span></span><br><span class="line"><span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;myio\\a.txt&quot;</span>); </span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line"><span class="keyword">while</span>((b = fis.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">    System.out.println((<span class="type">char</span>)b);</span><br><span class="line">&#125;</span><br><span class="line">fis.close();</span><br></pre></td></tr></table></figure><p><img src="C:\Users\wilbur\AppData\Roaming\Typora\typora-user-images\image-20240715164915746.png" alt="image-20240715164915746"></p><p> 注意，使用字节数组读取数据时，返回值表示的是此次读取了多少字节的数据，当数组没被读满时，只有前面的数据会被覆盖</p><p>eg. buffer长度为2，读取abcde，第一次读完后buffer内存储的是ab，第二次是cd，第三次只能读出一个e，这个e将c覆盖，因此此时buffer里存储的是ed</p><p><img src="C:\Users\wilbur\AppData\Roaming\Typora\typora-user-images\image-20240716141511643.png" alt="image-20240716141511643"></p><h2 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h2><p><img src="C:\Users\wilbur\AppData\Roaming\Typora\typora-user-images\image-20240716142651201.png" alt="image-20240716142651201"></p><h3 id="GBK字符集"><a href="#GBK字符集" class="headerlink" title="GBK字符集"></a>GBK字符集</h3><ul><li>GBK字符集完全兼容ASCII字符集</li><li>一个英文占一个字节，二进制第一位是0</li><li>一个中文占两个字节，二进制高位字节的第一位是1</li></ul><h3 id="Unicode字符集"><a href="#Unicode字符集" class="headerlink" title="Unicode字符集"></a>Unicode字符集</h3><p><img src="C:\Users\wilbur\AppData\Roaming\Typora\typora-user-images\image-20240716143924727.png" alt="image-20240716143924727" style="zoom:50%;" /></p><h2 id="Java中编码与解码的方法"><a href="#Java中编码与解码的方法" class="headerlink" title="Java中编码与解码的方法"></a>Java中编码与解码的方法</h2><p><img src="C:\Users\wilbur\AppData\Roaming\Typora\typora-user-images\image-20240716144833781.png" alt="image-20240716144833781"></p><h2 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h2><ul><li>字符流的底层其实还是字节流</li><li>输入流：一次读取一个字节，遇到中文时，一次读取多个字节</li><li>输出流：底层会把数据按照指定的编码方式进行编码，变成字节再写到文件中</li></ul><p><img src="C:\Users\wilbur\AppData\Roaming\Typora\typora-user-images\image-20240716145811061.png" alt="image-20240716145811061"></p><h2 id="FileReader"><a href="#FileReader" class="headerlink" title="FileReader"></a>FileReader</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建对象</span></span><br><span class="line"><span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;myio\\a.txt&quot;</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">//2.读取数据(与字节流的read()方法一模一样)</span></span><br><span class="line"><span class="comment">//细节：</span></span><br><span class="line"><span class="comment">//read()方法默认也是一个字节一个字节读取，如果读取到中文则会则读取多个</span></span><br><span class="line"><span class="comment">//在读取之后，方法的底层还会进行解码并转成十进制，把这个十进制值作为返回值</span></span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line"><span class="keyword">while</span>((b == fr.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">    System.out.println((<span class="type">char</span>)ch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.释放资源</span></span><br><span class="line">fr.close();</span><br></pre></td></tr></table></figure><p><img src="C:\Users\wilbur\AppData\Roaming\Typora\typora-user-images\image-20240716154424937.png" alt="image-20240716154424937"></p><h2 id="FileWriter"><a href="#FileWriter" class="headerlink" title="FileWriter"></a>FileWriter</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">FileWriter</span><span class="params">(File file)</span>;              <span class="comment">//创建字符输出流关联本地文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">FileWriter</span><span class="params">(String pathname)</span>;        </span><br><span class="line"><span class="keyword">public</span> <span class="title function_">FileWriter</span><span class="params">(File file, <span class="type">boolean</span> append)</span>; <span class="comment">//创建字符输出流关联本地文件,续写</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">FileWriter</span><span class="params">(String filename, <span class="type">boolean</span> append)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//成员方:write()方法的参数如果是整数，实际上写到文件中的是整数在字符集上对应的字符</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> c)</span>;               <span class="comment">//写出一个字符</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">write</span><span class="params">(String str)</span>;          <span class="comment">//写出一个字符串</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">write</span><span class="params">(String str, <span class="type">int</span> off, <span class="type">int</span> len)</span>; <span class="comment">//写出一个字符串的一部分</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">char</span>[] cbuf)</span>;         <span class="comment">//写出一个字符数组</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">char</span>[] cbuf, <span class="type">int</span> off, <span class="type">int</span> len)</span>; <span class="comment">//写出字符数组的一部分</span></span><br></pre></td></tr></table></figure><h1 id="高级流-IO基本流的拓展"><a href="#高级流-IO基本流的拓展" class="headerlink" title="高级流(IO基本流的拓展)"></a>高级流(IO基本流的拓展)</h1><h2 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h2><p><img src="C:\Users\wilbur\AppData\Roaming\Typora\typora-user-images\image-20240717140325937.png" alt="image-20240717140325937"></p><h3 id="字节缓冲流"><a href="#字节缓冲流" class="headerlink" title="字节缓冲流"></a>字节缓冲流</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;myio\\a.txt&quot;</span>));</span><br><span class="line"><span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;myio\\copy.txt&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//一次copy多个字节</span></span><br><span class="line"><span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="type">int</span> len;</span><br><span class="line"><span class="keyword">while</span>((len=bis.read(bytes)) != -<span class="number">1</span>)&#123;</span><br><span class="line">bos.write(bytes,<span class="number">0</span>,len);</span><br><span class="line">&#125;</span><br><span class="line">bis.close();</span><br><span class="line">bos.close();</span><br></pre></td></tr></table></figure><h3 id="字节缓冲流提高效率的原理"><a href="#字节缓冲流提高效率的原理" class="headerlink" title="字节缓冲流提高效率的原理"></a>字节缓冲流提高效率的原理</h3><p><img src="C:\Users\wilbur\AppData\Roaming\Typora\typora-user-images\image-20240717141737665.png" alt="image-20240717141737665"></p><h3 id="字符缓冲流"><a href="#字符缓冲流" class="headerlink" title="字符缓冲流"></a>字符缓冲流</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字符缓冲流特有的方法</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">readLine</span><span class="params">()</span>;                 <span class="comment">//读取一行数据，如果没有数据可读了，返回null</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">newLine</span><span class="params">()</span>;                    <span class="comment">//跨平台的换行</span></span><br><span class="line"></span><br><span class="line"><span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;myio\\.txt&quot;</span>));</span><br><span class="line">String line;</span><br><span class="line"><span class="keyword">while</span>((line=br.readLine()) != <span class="literal">null</span>)&#123;</span><br><span class="line">    System.out.println(line);</span><br><span class="line">&#125;</span><br><span class="line">br.close();</span><br></pre></td></tr></table></figure><h2 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h2><p><img src="C:\Users\wilbur\AppData\Roaming\Typora\typora-user-images\image-20240717143204648.png" alt="image-20240717143204648"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//利用转换流实现按照指定字符编码读取</span></span><br><span class="line"><span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;myio\\gbkfile.txt&quot;</span>), <span class="string">&quot;GBK&quot;</span>); <span class="comment">//第二个参数指定编码方式读取.目前已经被淘汰</span></span><br><span class="line"><span class="comment">// JDK11之后，字符流的新构造方法</span></span><br><span class="line"><span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReadr</span>(<span class="string">&quot;myio\\gbkfile.txt&quot;</span>, Charset.forname(<span class="string">&quot;GBK&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//利用转换流实现按照指定字符编码写出</span></span><br><span class="line"><span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;myio\\c.txt&quot;</span>, Charset.forname(<span class="string">&quot;GBK&quot;</span>));</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="序列化流-对象操作输出流"><a href="#序列化流-对象操作输出流" class="headerlink" title="序列化流/对象操作输出流"></a>序列化流/对象操作输出流</h2><p><img src="C:\Users\wilbur\AppData\Roaming\Typora\typora-user-images\image-20240717150431890.png" alt="image-20240717150431890" style="zoom: 67%;" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ObjectOutoutStream</span><span class="params">(OutputStream out)</span>;       <span class="comment">//把基本流包装为高级流</span></span><br><span class="line"><span class="comment">//成员方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">writeObject</span><span class="params">(Object obj)</span>;         <span class="comment">//把对象序列化(写出)到文件中去</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//细节：使用对象输出流将对象保存到文件时会出现NotSerializableException异常，必须要让这个对象类实现Serializable接口</span></span><br><span class="line"><span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">23</span>);         <span class="comment">//这里Student必须实现Serializable接口才能序列化</span></span><br><span class="line"><span class="type">ObjectOutoutStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutoutStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;myio\\a.txt&quot;</span>));</span><br><span class="line">oos.writeObject(stu);</span><br><span class="line">oos.close();</span><br></pre></td></tr></table></figure><h2 id="反序列化流-对象操作输入流"><a href="#反序列化流-对象操作输入流" class="headerlink" title="反序列化流/对象操作输入流"></a>反序列化流/对象操作输入流</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ObjectInputStream</span><span class="params">(InputStream in)</span>;           <span class="comment">//把基本流包装为高级流</span></span><br><span class="line"><span class="comment">//成员方法</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">readObject</span><span class="params">()</span>;                         <span class="comment">//把序列化到本地文件中的对象，读取到程序中来</span></span><br><span class="line"></span><br><span class="line"><span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;myio\\a.txt&quot;</span>));</span><br><span class="line"><span class="comment">//Object o = ois.readObject();</span></span><br><span class="line"><span class="type">Student</span> <span class="variable">o</span> <span class="operator">=</span> (Student)ois.readObject();  <span class="comment">//强转</span></span><br><span class="line">System.out.println(o);</span><br><span class="line">ois.close();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.当对象中的属性，方法发生变化时，需要添加serialVersionUID来保证对象能够正常被反序列化</span></span><br><span class="line"><span class="comment">//2.当我们不想序列化对象中的某些属性时，用transient关键字修饰该变量即可.标记后该成员变量不参与序列化过程</span></span><br></pre></td></tr></table></figure><h2 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h2><p>只有输出流，分为字节输出流PrintStream, 和 PrintWriter两个类</p><h3 id="字节打印流-—-底层没有缓冲区，自动刷新"><a href="#字节打印流-—-底层没有缓冲区，自动刷新" class="headerlink" title="字节打印流 — 底层没有缓冲区，自动刷新"></a>字节打印流 — 底层没有缓冲区，自动刷新</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">PrintStream</span><span class="params">(OutputStream / File / String)</span>;           <span class="comment">//关联字节输出流/文件/文件路径</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">PrintStream</span><span class="params">(String filename, Charset charset)</span>;       <span class="comment">//指定字符编码</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">PrintStream</span><span class="params">(OutputStream out, <span class="type">boolean</span> autoFlush)</span>;    <span class="comment">//自动刷新</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">PrintStream</span><span class="params">(OutputStream out, <span class="type">boolean</span> autoFlush, Charset charset)</span>;  <span class="comment">//指定字符编码且自动刷新</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//成员方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> b)</span>;              <span class="comment">//常规方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">println</span><span class="params">(X x)</span>;              <span class="comment">//打印任意数据，自动刷新，自动换行</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(X x)</span>;  <span class="comment">//打印任意数据，不换行</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printf</span><span class="params">(String format, ....)</span>;<span class="comment">//带占位符的打印语句，如%d，%s...不换行</span></span><br></pre></td></tr></table></figure><h3 id="字符打印流-—-底层有缓冲区，想要自动刷新需要手动开启"><a href="#字符打印流-—-底层有缓冲区，想要自动刷新需要手动开启" class="headerlink" title="字符打印流 — 底层有缓冲区，想要自动刷新需要手动开启"></a>字符打印流 — 底层有缓冲区，想要自动刷新需要手动开启</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">PrintWriter</span><span class="params">(Writer / File / String)</span>;           <span class="comment">//关联字节输出流/文件/文件路径</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">PrintWriter</span><span class="params">(String filename, Charset charset)</span>;       <span class="comment">//指定字符编码</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">PrintWriter</span><span class="params">(Writer w, <span class="type">boolean</span> autoFlush)</span>;    <span class="comment">//自动刷新</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">PrintWriter</span><span class="params">(OutputStream out, <span class="type">boolean</span> autoFlush, Charset charset)</span>;  <span class="comment">//指定字符编码且自动刷新</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//成员方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> b)</span>;              <span class="comment">//常规方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">println</span><span class="params">(X x)</span>;              <span class="comment">//打印任意数据，自动刷新，自动换行</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(X x)</span>;  <span class="comment">//打印任意数据，不换行</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printf</span><span class="params">(String format, ....)</span>;<span class="comment">//带占位符的打印语句，如%d，%s...不换行</span></span><br></pre></td></tr></table></figure><h2 id="压缩流"><a href="#压缩流" class="headerlink" title="压缩流"></a>压缩流</h2><p><img src="C:\Users\wilbur\AppData\Roaming\Typora\typora-user-images\image-20240718145816952.png" alt="image-20240718145816952" style="zoom:67%;" /></p><p>压缩包中的每一个文件，都是一个ZipEntry对象</p><p>解压的本质：就是把每一个ZipEntry对象按照层级拷贝到本地另一个文件夹中</p><p>压缩的本质：把每一个文件/文件夹 看成ZipEntry对象放入压缩包中</p><h3 id="解压缩流"><a href="#解压缩流" class="headerlink" title="解压缩流"></a>解压缩流</h3><h3 id="压缩流-1"><a href="#压缩流-1" class="headerlink" title="压缩流"></a>压缩流</h3><h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="启动线程的三种方式"><a href="#启动线程的三种方式" class="headerlink" title="启动线程的三种方式"></a>启动线程的三种方式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//多线程的第一种启动方式</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.自己定义一个类继承Thread 2.重写run方法 3.创建子类对象，启动线程(start方法而不是run方法)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//书写线程要执行的代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">MyThread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line"><span class="type">MyThread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//多线程的第二种启动方式</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.自己定义一个类实现Runnable接口 2.重写run方法 3.创建自己的类对象 4.创建一个Thread类的对象，并开启线程</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRun</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//书写线程要执行的代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">MyRun</span> <span class="variable">mr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRun</span>();</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(mr);</span><br><span class="line">t1.start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//多线程的第三种启动方式</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.创建一个自定义类MyCallable类，实现Callable接口</span></span><br><span class="line"><span class="comment">2.重写call方法，该方法是有返回值的，表示多线程运行的结果</span></span><br><span class="line"><span class="comment">3.创建MyCallable的对象（表示多线程要执行的任务）</span></span><br><span class="line"><span class="comment">4.创建FutureTask的对象（作用管理多线程运行的结果）</span></span><br><span class="line"><span class="comment">5.创建Thread类的对象，并启动（表示线程）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt;&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">100</span>; i++)sum+=i;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">MyCallalbe</span> <span class="variable">mc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyCallalbe</span>();  <span class="comment">//创建MyCallable的对象（表示多线程要执行的任务）</span></span><br><span class="line">FutrueTask&lt;Integer&gt; ft = <span class="keyword">new</span> <span class="title class_">FutrueTask</span>&lt;&gt;(mc); <span class="comment">//创建FutrueTask的对象（作用管理多线程运行的结果）</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ft);</span><br><span class="line">t1.start();</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="常见的成员方法"><a href="#常见的成员方法" class="headerlink" title="常见的成员方法"></a>常见的成员方法</h2><p><img src="C:\Users\wilbur\AppData\Roaming\Typora\typora-user-images\image-20240801152545051.png" alt="image-20240801152545051"></p><h3 id="守护线程：当非守护线程结束后，守护进程会陆陆续续结束"><a href="#守护线程：当非守护线程结束后，守护进程会陆陆续续结束" class="headerlink" title="守护线程：当非守护线程结束后，守护进程会陆陆续续结束"></a>守护线程：当非守护线程结束后，守护进程会陆陆续续结束</h3><h2 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h2><p><img src="C:\Users\wilbur\AppData\Roaming\Typora\typora-user-images\image-20240801154827871.png" alt="image-20240801154827871"></p><h2 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Demo:三个窗口共同售出100张票</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> ticket=<span class="number">0</span>; <span class="comment">//static修饰表示这个类所有对象都贡献ticket变量</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line"><span class="keyword">synchronized</span>(MyThread.class)&#123;<span class="comment">//锁对象一定要是唯一的，一般使用类的字节码对象</span></span><br><span class="line">                <span class="keyword">if</span>(ticket &lt; <span class="number">100</span>)&#123;</span><br><span class="line">   ticket++;</span><br><span class="line">                      System.out.println(getName() + <span class="string">&quot;正在卖第&quot;</span> + ticket + <span class="string">&quot;张票 !!!&quot;</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h2><p><img src="C:\Users\wilbur\AppData\Roaming\Typora\typora-user-images\image-20240802142317033.png" alt="image-20240802142317033"></p><h2 id="Lock锁"><a href="#Lock锁" class="headerlink" title="Lock锁"></a>Lock锁</h2><p><img src="C:\Users\wilbur\AppData\Roaming\Typora\typora-user-images\image-20240802143219732.png" alt="image-20240802143219732"></p><p>注意：类中的锁对象一般要用static修饰，表示唯一的锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">lock.lock();</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(ticket == <span class="number">100</span>)<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                    ticket++;</span><br><span class="line">                    Systen.out.println(<span class="string">&quot;....&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="生产者消费者同步问题"><a href="#生产者消费者同步问题" class="headerlink" title="生产者消费者同步问题"></a>生产者消费者同步问题</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//常见方法</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">wait</span><span class="params">()</span>;   <span class="comment">//阻塞当前进程，直到被其他线程唤醒</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">notify</span><span class="params">()</span>; <span class="comment">//随机唤醒单个线程，具有随机性</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">notifyAll</span><span class="params">()</span>; <span class="comment">//唤醒所有线程</span></span><br></pre></td></tr></table></figure><h2 id="阻塞队列的继承结构"><a href="#阻塞队列的继承结构" class="headerlink" title="阻塞队列的继承结构"></a>阻塞队列的继承结构</h2><p><img src="C:\Users\wilbur\AppData\Roaming\Typora\typora-user-images\image-20240802152844514.png" alt="image-20240802152844514"></p><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Executors:线程池的工具类通过调用方法返回不同类型的线程池对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span>; <span class="comment">//创建一个没有上限/上限为int最大的线程池</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads)</span>; <span class="comment">// 创建有上限的线程池</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.获取线程池对象</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">pool1</span> <span class="operator">=</span> Executor.newCachedThreadPool();</span><br><span class="line"><span class="comment">//2.提交任务</span></span><br><span class="line">pool1.submit(任务<span class="number">1</span>);</span><br><span class="line">pool1.submit(任务<span class="number">2</span>);</span><br><span class="line">pool1.submit(任务<span class="number">3</span>);</span><br><span class="line">pool1.submit(任务<span class="number">4</span>);</span><br><span class="line"><span class="comment">//3.销毁线程池（一般不销毁）</span></span><br><span class="line"><span class="comment">//pool1.shutdowm();</span></span><br></pre></td></tr></table></figure><h3 id="线程池有原理"><a href="#线程池有原理" class="headerlink" title="线程池有原理"></a>线程池有原理</h3><p><img src="C:\Users\wilbur\AppData\Roaming\Typora\typora-user-images\image-20240802160157439.png" alt="image-20240802160157439" style="zoom:50%;" /></p><h2 id="自定义线程池"><a href="#自定义线程池" class="headerlink" title="自定义线程池"></a>自定义线程池</h2><h3 id="构造方法中7个参数的含义"><a href="#构造方法中7个参数的含义" class="headerlink" title="构造方法中7个参数的含义"></a>构造方法中7个参数的含义</h3><p><img src="C:\Users\wilbur\AppData\Roaming\Typora\typora-user-images\image-20240802161500281.png" alt="image-20240802161500281" style="zoom:33%;" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ThreadPoolExecutor</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line"><span class="number">3</span>,  <span class="comment">//核心线程数量，不能小于0</span></span><br><span class="line"><span class="number">6</span>,  <span class="comment">//最大线程数，不能小于0，且最大数量 &gt;= 核心线程数, 根据这个可以计算出临时线程的数量</span></span><br><span class="line">    <span class="number">60</span>, <span class="comment">//空闲(的临时)线程最大存活时间</span></span><br><span class="line">    TimeUnit.SECONDS, <span class="comment">//空闲时间的单位</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">3</span>), <span class="comment">//阻塞队列</span></span><br><span class="line">    Executors.defaultThreadFactory(), <span class="comment">//创建线程工厂</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy() <span class="comment">//任务的拒绝策略</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ol><li>创建一个空的线程池</li><li>有任务提交时，线程池会创建线程去执行任务，执行完毕归还线程</li><li>当核心线程满时，再提交任务就会排队阻塞</li><li>当核心线程满，阻塞队列满时，会创建临时线程</li><li>当核心线程满，阻塞队列满，临时线程满时，会触发任务拒绝策略</li></ol><p><img src="C:\Users\wilbur\AppData\Roaming\Typora\typora-user-images\image-20240802161401597.png" alt="image-20240802161401597" style="zoom:33%;" /></p><h3 id="任务拒绝策略"><a href="#任务拒绝策略" class="headerlink" title="任务拒绝策略"></a>任务拒绝策略</h3><p><img src="C:\Users\wilbur\AppData\Roaming\Typora\typora-user-images\image-20240802161417165.png" alt="image-20240802161417165" style="zoom:50%;" /></p><h3 id="自定义线程池的大小"><a href="#自定义线程池的大小" class="headerlink" title="自定义线程池的大小"></a>自定义线程池的大小</h3><p><img src="C:\Users\wilbur\AppData\Roaming\Typora\typora-user-images\image-20240802164656285.png" alt="image-20240802164656285" style="zoom:33%;" /></p><h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">InetAddress</span> <span class="variable">address</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;LAPTOP-BEA61MHQ&quot;</span>);</span><br><span class="line">System.out.println(address);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> address.getHostName();</span><br><span class="line">System.out.println(name);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">ip</span> <span class="operator">=</span> address.getHostAddress();</span><br><span class="line">System.out.println(ip);</span><br></pre></td></tr></table></figure><h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><h2 id="获取class对象的三种方式"><a href="#获取class对象的三种方式" class="headerlink" title="获取class对象的三种方式"></a>获取class对象的三种方式</h2><ol><li>Class.forName(“全类名”);  主要用在源代码阶段， 最常用</li><li>类名.class   主要用在加载阶段</li><li>对象.getClass( )    主要用在运行阶段</li></ol><p><img src="C:\Users\wilbur\AppData\Roaming\Typora\typora-user-images\image-20240804153636476.png" alt="image-20240804153636476"></p><h2 id="利用反射获取构造方法"><a href="#利用反射获取构造方法" class="headerlink" title="利用反射获取构造方法"></a>利用反射获取构造方法</h2><p><img src="C:\Users\wilbur\AppData\Roaming\Typora\typora-user-images\image-20240804155738958.png" alt="image-20240804155738958" style="zoom: 50%;" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//1.获取字节码文件对象</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.itheima.myreflect2.Student&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取构造方法</span></span><br><span class="line">Constructor[] cons1 = clazz.getConstructors();</span><br><span class="line"><span class="keyword">for</span>(Constructor con : cons1)&#123;</span><br><span class="line">System.out.println(con);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Constructor[] cons2 = clazz.getDeclaredConstructors();</span><br><span class="line"><span class="keyword">for</span>(Constructor con : cons2)&#123;</span><br><span class="line">System.out.println(con);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Constructor</span> <span class="variable">con3</span> <span class="operator">=</span> clazz.getConstructor();  <span class="comment">//不传递参数，返回的就是空参构造</span></span><br><span class="line">System.out.println(con3);</span><br><span class="line"></span><br><span class="line"><span class="comment">//传入相应构造方法中参数的字节码，返回相应的构造方法</span></span><br><span class="line"><span class="type">Constructor</span> <span class="variable">con4</span> <span class="operator">=</span> clazz.getDeclaredConstructor(String.class, <span class="type">int</span>.class)  </span><br><span class="line">System.out.println(con4);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取构造方法中的参数</span></span><br><span class="line">Parameter[] parameters = con4.getParameter();</span><br><span class="line"><span class="keyword">for</span>(Parameter parameter : parameters)&#123;</span><br><span class="line">    System.out.println(parameter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//利用构造方法创建对象</span></span><br><span class="line">con4.setAccessible(<span class="literal">true</span>); <span class="comment">//表示临时取消权限校验(con4为private构造方法，不取消会报错)</span></span><br><span class="line"><span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> (Student) con4.newInstance(<span class="string">&quot;张三&quot;</span>, <span class="number">23</span>);</span><br><span class="line">System.out.println(stu);</span><br></pre></td></tr></table></figure><h2 id="利用反射获取成员变量"><a href="#利用反射获取成员变量" class="headerlink" title="利用反射获取成员变量"></a>利用反射获取成员变量</h2><p><img src="C:\Users\wilbur\AppData\Roaming\Typora\typora-user-images\image-20240804155821835.png" alt="image-20240804155821835" style="zoom:50%;" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意：getFields()获取到的属性包括本类以及所有父类中声明为public的属性</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forNmae(<span class="string">&quot;con.itheima.myreflect3.Student&quot;</span>);</span><br><span class="line">Field[] fields = clazz.getFields();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(Field field : fields)&#123;</span><br><span class="line">System.out.println(field);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//....其他的方法与Constructor类似</span></span><br></pre></td></tr></table></figure><h2 id="利用反射获取成员方法"><a href="#利用反射获取成员方法" class="headerlink" title="利用反射获取成员方法"></a>利用反射获取成员方法</h2><p><img src="C:\Users\wilbur\AppData\Roaming\Typora\typora-user-images\image-20240804160823523.png" alt="image-20240804160823523" style="zoom:50%;" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.itheima.myreflect4.Student&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取单一的方法对象</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">m</span> <span class="operator">=</span> clazz.getDeclaredMethod(<span class="string">&quot;eat&quot;</span>, String.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取修饰符</span></span><br><span class="line"><span class="type">int</span> <span class="variable">modifiers</span> <span class="operator">=</span> m.getModifiers();</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取方法名</span></span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> m.getName();</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取方法的形参</span></span><br><span class="line">Parameter[] parameters = m.getParameters();</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取方法抛出的异常</span></span><br><span class="line">Class[] exceptionTypes = m.getExceptionTypes();</span><br><span class="line"></span><br><span class="line"><span class="comment">//运行方法</span></span><br><span class="line"><span class="comment">//Object invoke(Object obj, Object...args)</span></span><br><span class="line"><span class="comment">//参数一：用obj对象调用该方法  参数二：调用方法传递的实参</span></span><br><span class="line"><span class="comment">//返回值：有就用变量接受，没有就直接调用即可</span></span><br><span class="line"><span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">m.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> (String)m.invoke(s, <span class="string">&quot;热干面&quot;</span>);</span><br><span class="line">System.out.println(result);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="动态代理-听不懂"><a href="#动态代理-听不懂" class="headerlink" title="动态代理-听不懂"></a>动态代理-听不懂</h1><p>特点：五侵入式的给代码增加额外功能</p><p><img src="C:\Users\wilbur\AppData\Roaming\Typora\typora-user-images\image-20240804163710604.png" alt="image-20240804163710604" style="zoom:67%;" /></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;面向对象三大特性：封装，继承，多态&quot;&gt;&lt;a href=&quot;#面向对象三大特性：封装，继承，多态&quot; class=&quot;headerlink&quot; title=&quot;面向对象三大特性：封装，继承，多态&quot;&gt;&lt;/a&gt;面向对象三大特性：封装，继承，多态&lt;/h1&gt;&lt;h2 id=&quot;继承&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="编程Coding" scheme="https://github.wilbur-lz.cn/categories/%E7%BC%96%E7%A8%8BCoding/"/>
    
    
    <category term="JavaSE" scheme="https://github.wilbur-lz.cn/tags/JavaSE/"/>
    
  </entry>
  
</feed>
