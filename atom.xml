<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Coding Blog</title>
  <icon>https://www.gravatar.com/avatar/a8f9eea32979fcc0ed3972ee87db09aa</icon>
  <subtitle>摸学并进 躺卷交融.</subtitle>
  <link href="https://github.wilbur-lz.cn/atom.xml" rel="self"/>
  
  <link href="https://github.wilbur-lz.cn/"/>
  <updated>2024-10-11T08:49:34.756Z</updated>
  <id>https://github.wilbur-lz.cn/</id>
  
  <author>
    <name>整点薯条</name>
    <email>854309295@qq.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JavaSE</title>
    <link href="https://github.wilbur-lz.cn/posts/f7ede91d.html"/>
    <id>https://github.wilbur-lz.cn/posts/f7ede91d.html</id>
    <published>2024-10-11T08:49:34.756Z</published>
    <updated>2024-10-11T08:49:34.756Z</updated>
    
    <content type="html"><![CDATA[<h1 id="面向对象三大特性：封装，继承，多态"><a href="#面向对象三大特性：封装，继承，多态" class="headerlink" title="面向对象三大特性：封装，继承，多态"></a>面向对象三大特性：封装，继承，多态</h1><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h4 id="继承中构造方法的特点："><a href="#继承中构造方法的特点：" class="headerlink" title="继承中构造方法的特点："></a>继承中构造方法的特点：</h4><ul><li>父类中的构造方法不会被子类继承(否则构造方法名与类名不一致)</li><li>子类中所有的构造方法默认先访问父类中的无参构造，在执行自己</li></ul><p>使用super关键字访问父类的方法</p><h4 id="this，super关键字："><a href="#this，super关键字：" class="headerlink" title="this，super关键字："></a>this，super关键字：</h4><ul><li>this：表示当前方法调用者的地址值</li><li>super：代表父类的存储空间</li></ul><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态的表现形式：父类类型 对象名 = 子类对象</p><p>多态的前提：</p><ul><li>有继承 / 实现关系</li><li>有父类的引用指向子类对象</li><li>有方法重写</li></ul><h3 id="多态调用成员的特点："><a href="#多态调用成员的特点：" class="headerlink" title="多态调用成员的特点："></a>多态调用成员的特点：</h3><ul><li>变量调用：编译看左边，运行也看左边</li><li>方法调用：编译看左边，运行看右边</li></ul><h3 id="instanceof关键字"><a href="#instanceof关键字" class="headerlink" title="instanceof关键字"></a>instanceof关键字</h3><p>判断父类对象是否为某一特定的子类</p><h2 id="包，final，权限修饰符，代码块"><a href="#包，final，权限修饰符，代码块" class="headerlink" title="包，final，权限修饰符，代码块"></a>包，final，权限修饰符，代码块</h2><h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><p>使用规则:</p><ul><li>使用同一个包中的类是，不需要导包</li><li>java.lang包中的类不需要导包</li><li>其他情况都需要导包</li><li>如果同时使用两个包中的同名类，需要使用全类名</li></ul><h3 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h3><ul><li><p>修饰方法：表明该方法是最终方法，不能被重写</p></li><li><p>修饰类：表明该类是最终类，不能被继承</p></li><li><p>修饰变量：叫做常量，只能被赋值一次。</p><p>变量为基本类型 —-&gt; 数据值不能发生改变</p><p>变量为引用数据类型 —-&gt; 变量存储的地址值不能发生改变,对象内部的可以改变</p></li></ul><h3 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h3><p>范围从大到小：public &gt; protected &gt; 缺省 &gt; private</p><p>一般开发中只使用public 和 private，一般而言成员变量private，成员方法public。但如果方法中的代码是抽取其他方法中共性代码，这个方法也要用private修饰</p><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><ul><li>局部代码块：提前结束变量的生命周期</li><li>构造代码块：将多个构造方法中重复的部分写在成员变量的位置，优先于构造方法执行(淘汰)</li><li>静态代码块：用static修饰，随着类的加载而加载，并且自动触发，只执行一次</li></ul><h2 id="抽象类-abstract"><a href="#抽象类-abstract" class="headerlink" title="抽象类(abstract)"></a>抽象类(abstract)</h2><p>如果一个类中存在抽象方法，则这个类必须定义为抽象类</p><p>关键字abstract写在权限修饰符之后</p><ul><li>抽象类不能实例化</li><li>抽象类中不一定有抽象方法，由抽象方法的类一定是抽象类</li><li>可以有构造方法 —-&gt; 当子类创建对象时，给父类中的属性进行赋值</li><li>抽象类的子类<ol><li>要么重写抽象类中的所有抽象方法</li><li>要么也是抽象类</li></ol></li></ul><h2 id="接口-interface"><a href="#接口-interface" class="headerlink" title="接口(interface)"></a>接口(interface)</h2><p>接口与类是同一级的，类用class定义，接口用interface定义，二者之间是实现implements的关系</p><p>可以粗略理解为：抽象更多描述的是事物；接口描述的是一种规则，更多描述的是行为.</p><p>关键字interface写在权限修饰符之后</p><ul><li><p>接口不能实例化</p></li><li><p>接口与类之间是实现关系，通过implements关键字表示</p><p>public class 类名 implements 接口名 { }</p></li><li><p>接口的子类(实现类)：</p><ol><li>要么重写接口中的所由抽象方法</li><li>要么是抽象类</li></ol><p>接口与类的实现关系，可以单实现，也可以多实现</p><p>public class 类名 implements 接口1，接口2 { }</p></li></ul><h3 id="接口中成员的特点"><a href="#接口中成员的特点" class="headerlink" title="接口中成员的特点"></a>接口中成员的特点</h3><ul><li>成员变量：只能是常量，默认修饰符public static final</li><li>构造方法：没有</li><li>成员方法：只能是抽象方法，默认修饰符public static final</li></ul><h3 id="接口与类之间的关系"><a href="#接口与类之间的关系" class="headerlink" title="接口与类之间的关系"></a>接口与类之间的关系</h3><ul><li>类与类的关系：继承关系，只能单继承，不能多继承，但可以多层击沉</li><li>类与接口的关系：实现关系，可以单实现也可以多实现，还可以在继承一个类的同时实现多个接口</li><li>接口与接口的关系：继承关系，可以单继承，也可以多继承</li></ul><h3 id="接口多态"><a href="#接口多态" class="headerlink" title="接口多态"></a>接口多态</h3><p>​    是指当一个方法的参数是接口时，可以传递接口所有实现类的对象</p><h3 id="JKD8以后接口中的新特性"><a href="#JKD8以后接口中的新特性" class="headerlink" title="JKD8以后接口中的新特性"></a>JKD8以后接口中的新特性</h3><ul><li>默认方法</li><li>静态方法</li><li>私有方法 —- &gt; jkd9以后出现</li></ul><h3 id="适配器设计模式"><a href="#适配器设计模式" class="headerlink" title="适配器设计模式"></a>适配器设计模式</h3><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><ul><li>内部类可以直接访问外部类的成员，包括私有</li><li>外部类要访问内部类的成员，必须创建对象（在外部类的方法中直接创建内部类的对象,然后访问）</li></ul><h3 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h3><ul><li><p>成员内部类可以被一些修饰符所修饰，效果与普通类一样</p></li><li><p>获取成员内部类的方法：1.外部类提供内部类对象的方法；2.外部类.内部类 对象名 = 外部类对象.内部类对象</p><p>Outer.Inner oi = new Outer( ). new Inner( );</p></li></ul><h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><p>静态内部类只能访问外部类中的静态变量与静态方法，如果想访问非静态的需要创建对象</p><p>创建静态内部类对象的格式： 外部类名.内部类名 对象名 = new 外部类名.内部类名( )</p><p>调用非静态方法的格式：先创建对象，用对象调用</p><h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h3><p>将内部类定义在方法里面，类似于方法中的变量</p><p>外界无法直接使用，需要在方法内部创建对象并使用</p><p>该类可以直接访问外部类的成员，也可以访问方法内的局部变量</p><h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>隐藏了名称的内部类</p><p>定义方式:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> 类名/接口名&#123;</span><br><span class="line">重写方法;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>整体是一个类的子类或接口的实现类对象</p><h2 id="Object-与-Objects类"><a href="#Object-与-Objects类" class="headerlink" title="Object 与 Objects类"></a>Object 与 Objects类</h2><h3 id="Object类中的方法"><a href="#Object类中的方法" class="headerlink" title="Object类中的方法"></a>Object类中的方法</h3><ol><li><p>toString( )方法</p></li><li><p>equals( )方法</p><ul><li>String类中的equals( )方法首先判断参数是否为字符串，如果是再比较内部的属性值，但如果不是，则直接返回false</li><li>StringBuulder类中没有equals( )方法，因此它会继承父类Object中的equals( )方法，直接比较两个对象的地址值</li></ul></li><li><p>clone( )方法</p><p>书写细节：重写Object类中的clone( )方法，让javabean类实现Cloneable接口，创建原对象并调用clone( )</p><ul><li><strong>浅克隆/浅拷贝</strong>(Object中的克隆)：不管对象内部的属性是基本数据类型还是引用数据类型，都完全拷贝过来</li><li><strong>深克隆/深拷贝：</strong>基本数据类型拷贝过来，字符串复用串池中的字符串，引用数据类型会在堆中重新创建新的</li></ul></li></ol><h3 id="Objects类"><a href="#Objects类" class="headerlink" title="Objects类"></a>Objects类</h3><p>Objects是一个工具类，提供了一些方法去完成一些功能</p><ol><li>equals( )方法：先做非空判断，再比较两个对象</li><li>isNull( )方法：判断对象是否为null</li><li>nonNull( )方法：判断对象是否不为null</li></ol><h2 id="BigInteger"><a href="#BigInteger" class="headerlink" title="BigInteger"></a>BigInteger</h2><p>对象一旦创建,内部的数据不能发生改变</p><p>只要进行计算都会产生一个新的BigInteger对象</p><ol><li>public BigInteger(int num, Random rnd)  获取随即的大整数，范围[0 ~ 2的num次方 - 1]</li><li>public BigInteger(String val)  获取指定的大整数，val必须为整数</li><li>public BigInteger(String val, int radix)  获取指定进制的大整数</li><li>public static BigInteger valueof(long val) 静态方法获取BigInteger对象，-16~16之间有内部优化</li></ol><h3 id="常见方法"><a href="#常见方法" class="headerlink" title="常见方法"></a>常见方法</h3><p>add, substract, nultiply, divide ……</p><h3 id="BigInteger底层原理"><a href="#BigInteger底层原理" class="headerlink" title="BigInteger底层原理"></a>BigInteger底层原理</h3><h2 id="BigDecima"><a href="#BigDecima" class="headerlink" title="BigDecima"></a>BigDecima</h2><p>解决小数在计算机中运算精度的问题 —————— 涉及小数在计算机底层的存储原理 IEEE </p><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>用于校验字符串是否满足一定规则</p><p>在一段文本中查找满足要求的内容</p><p><strong>调用方法：</strong> String对象名.matches(正则表达式);</p><h3 id="语法规则："><a href="#语法规则：" class="headerlink" title="语法规则："></a>语法规则：<img src="C:\Users\wilbur\Documents\WeChat Files\wxid_v5h1rlf6c62222\FileStorage\Temp\a0e51ee74860a39278f607f930fe03e.jpg" alt="a0e51ee74860a39278f607f930fe03e"></h3><p>Pattern类：表示正则表达式</p><p>Matcher类：文本匹配器，作用为按照正则表达式的规则去读取字符串，从头开始读取，在大串中招符合匹配规则的子串</p><h3 id="爬取文本中满足要求的内容"><a href="#爬取文本中满足要求的内容" class="headerlink" title="爬取文本中满足要求的内容"></a>爬取文本中满足要求的内容</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Java自从95年问世以来，经历了很多版本，目前企业中用的最多的是Java8和Java11，因为这两个是长期支持版本，下一个长期支持版本是Java17,相信在未来不久Java17也会逐渐登上历史舞台&quot;</span></span><br><span class="line"><span class="comment">// 找出里面所有的Java**</span></span><br><span class="line"><span class="type">Pattern</span> <span class="variable">p</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;Java\\d&#123;0,2&#125;&quot;</span>);   <span class="comment">//获取正则表达式对象</span></span><br><span class="line"><span class="type">Matcher</span> <span class="variable">m</span> <span class="operator">=</span> p.matcher(str);                    <span class="comment">//获取文本匹配器对象</span></span><br><span class="line"><span class="keyword">while</span>(m.find())&#123; <span class="comment">//find()方法，如果没有返回false,否则返回true，在底层记录子串的 起始索引 和  结束索引+1</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> m.group();<span class="comment">//group方法会根据find()方法记录的所有进行字符串的截取，截取的小串返回</span></span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="时间类"><a href="#时间类" class="headerlink" title="时间类"></a>时间类</h2><h3 id="Date类"><a href="#Date类" class="headerlink" title="Date类"></a>Date类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Date</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> time; <span class="comment">//当前时间的毫秒值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Date</span><span class="params">()</span>&#123;<span class="built_in">this</span>.time = System.currentTimeMillis(); &#125; <span class="comment">//空参构造</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Date</span><span class="params">(<span class="type">long</span> time)</span>&#123;<span class="built_in">this</span>.time = time&#125;                <span class="comment">//带参构造</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getTime</span><span class="params">()</span>&#123;<span class="keyword">return</span> time&#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTime</span><span class="params">(<span class="type">long</span> time)</span>&#123; <span class="built_in">this</span>.time = time&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SimpleDateFormat类"><a href="#SimpleDateFormat类" class="headerlink" title="SimpleDateFormat类"></a>SimpleDateFormat类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">SimpleDateFormat</span><span class="params">()</span>                      <span class="comment">//默认格式</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">SimpleDateFormat</span><span class="params">(String pattern)</span>        <span class="comment">//指定格式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//常用方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">format</span><span class="params">(Date date)</span>           <span class="comment">//格式化(日期对象-&gt;字符串)</span></span><br><span class="line"><span class="keyword">public</span> Date <span class="title function_">parse</span><span class="params">(String source)</span>                <span class="comment">//解析(字符串-&gt;日期对象)</span></span><br></pre></td></tr></table></figure><h3 id="Calendar类"><a href="#Calendar类" class="headerlink" title="Calendar类"></a>Calendar类</h3><ul><li>Calendar类是一个抽象类，需要用getInstance( )方法获取其子类对象</li><li>月份：范围0~11； 星期：(日，一，二，三，四，五，六)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Date <span class="title function_">getTime</span><span class="params">()</span>;       <span class="comment">//获取日期对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="title function_">setTime</span><span class="params">(Date date)</span>;   <span class="comment">//给日历设置日期对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getTimeInMillis</span><span class="params">()</span>;     <span class="comment">//拿到时间毫秒值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTimeInMillis</span><span class="params">(<span class="type">long</span> millis)</span>; <span class="comment">//给日历设置时间毫秒值</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> field)</span>;         <span class="comment">//取日历中的某个字段信息</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(<span class="type">int</span> field, <span class="type">int</span> value)</span>;<span class="comment">//修改日历的某个字段的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> field, <span class="type">int</span> amount)</span>;<span class="comment">//为某个字段增加/减少值</span></span><br></pre></td></tr></table></figure><h3 id="ZoneId类"><a href="#ZoneId类" class="headerlink" title="ZoneId类"></a>ZoneId类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Set&lt;String&gt; <span class="title function_">getAvailableZoneIds</span><span class="params">()</span>; <span class="comment">//获取Java中支持的所有时区</span></span><br><span class="line"><span class="keyword">static</span> ZoneId <span class="title function_">systemDefault</span><span class="params">()</span>;            <span class="comment">//获取系统默认时区</span></span><br><span class="line"><span class="keyword">static</span> ZoneId <span class="title function_">of</span><span class="params">(String zoneId)</span>;          <span class="comment">//获取一个指定时区</span></span><br></pre></td></tr></table></figure><p>Instant时间戳类/ ZoneDateTime带时区的时间类/ LocalDate/ LocalTime/ LocalDateTime….</p><h3 id="时间工具类"><a href="#时间工具类" class="headerlink" title="时间工具类"></a>时间工具类</h3><p>Duration时间间隔类 / Period类 / ChronoUnit时间间隔</p><h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><p>基本数据类型对应的引用类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自动装箱</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;    <span class="comment">//在底层，还是会调用valueof得到一个Integer对象</span></span><br><span class="line"><span class="comment">//自动拆箱</span></span><br><span class="line"><span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;</span><br></pre></td></tr></table></figure><h2 id="Arrays工具类"><a href="#Arrays工具类" class="headerlink" title="Arrays工具类"></a>Arrays工具类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">toString</span><span class="params">(数组)</span>;       <span class="comment">//将数组拼接为一个字符串</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(数组，查找的元素)</span>; <span class="comment">//二分查找法查找元素</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] copyOf(数组，数组长度); <span class="comment">//拷贝数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] copyOfRange(原数组，起始索引，结束索引); <span class="comment">//拷贝指定范围数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> viod <span class="title function_">fill</span><span class="params">(数组，元素)</span>; <span class="comment">//用元素填充数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(数组)</span>; <span class="comment">//按默认方式(升序)对数组进行排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(数组，排序规则)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">sort()底层原理：</span></span><br><span class="line"><span class="comment">·利用插入排序+二分查找的方式进行排序</span></span><br><span class="line"><span class="comment">·默认把0索引的数据当作是有序序列，1索引到最后的默认为无序序列</span></span><br><span class="line"><span class="comment">·遍历无序序列得到里面的每一个元素，假设当前为A</span></span><br><span class="line"><span class="comment">·把A往有序序列中进行插入，再插入时，是利用二分查找确定A的插入点</span></span><br><span class="line"><span class="comment">·拿着A元素，跟插入点的元素进行比较，比较的规则就是compare方法的方法体</span></span><br><span class="line"><span class="comment">·返回值为负数，拿着A继续与前面的元素比较</span></span><br><span class="line"><span class="comment">·返回值为非负数，拿着A继续与后面的元素比较，直到确定A的最终位置</span></span><br><span class="line"><span class="comment">排序规则：</span></span><br><span class="line"><span class="comment">1. 只能给引用数据类型的数组进行排序,如果待排序数组是基本数据类型的，需要变成对应的包装类数组</span></span><br><span class="line"><span class="comment">2. 排序规则是一个接口，因此调用该方法时需要传入其实现类对象，一般采取匿名内部类的方式</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">() -&gt; &#123;&#125; <span class="comment">// ()对应形参，&#123;&#125;对应方法体</span></span><br></pre></td></tr></table></figure><ul><li>Lambda表达式可以用来简化匿名内部类的书写</li><li>Lambda表达式只能简化函数式接口的匿名内部类的写法</li><li>函数式接口：有且仅有一个抽象方法的接口。接口上方可以加  @FunctionalInterface注解</li></ul><h3 id="省略规则"><a href="#省略规则" class="headerlink" title="省略规则"></a>省略规则</h3><ul><li>参数类型可以不写</li><li>如果只有一个参数，参数类型可以省略，( )可以省略</li><li>如果Lambda表达式的方法体只有一个，可以同时省去{ }, return, ; 。</li></ul><h1 id="集合体系结构"><a href="#集合体系结构" class="headerlink" title="集合体系结构"></a>集合体系结构</h1><h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><p><img src="C:\Users\wilbur\Documents\WeChat Files\wxid_v5h1rlf6c62222\FileStorage\Temp\61852b6212e8d66365b8d2dd814e0d2.jpg" alt="61852b6212e8d66365b8d2dd814e0d2" style="zoom:50%;" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span>;                <span class="comment">//添加对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span>;                    <span class="comment">//清空元素</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(E e)</span>;             <span class="comment">//删除指定对象</span></span><br><span class="line"><span class="comment">//contains方法底层是调用的父类的equals方法，如果集合中存储的为自定义对象(引用数据类型),则需要重写equals方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object obj)</span>;    <span class="comment">//判断是否包含obj </span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>;               <span class="comment">//判空</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>;                      <span class="comment">//集合大小</span></span><br></pre></td></tr></table></figure><h3 id="遍历方式"><a href="#遍历方式" class="headerlink" title="遍历方式"></a>遍历方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;String&gt; coll = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// 迭代器遍历</span></span><br><span class="line">Iterator&lt;String&gt; it = coll.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNest())&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> it.next();</span><br><span class="line">    System.out.println(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//增强for遍历 ------- 只能用于所有单列集合和数组</span></span><br><span class="line"><span class="comment">//修改遍历变量，不会使集合中的数据</span></span><br><span class="line"><span class="keyword">for</span>(String str : coll)&#123;</span><br><span class="line">    System.out.println(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Lambda表达式遍历</span></span><br><span class="line">coll.forEach(s -&gt; System.out.println(s));</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E emelent)</span>;       <span class="comment">//在指定位置插入元素</span></span><br><span class="line">E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span>;                  <span class="comment">//在指定位置删除元素，并将该元素返回</span></span><br><span class="line">E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E element)</span>;          <span class="comment">//修改指定位置的元素，返回被修改的元素</span></span><br><span class="line">E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span>;                     <span class="comment">//获取指定位置的元素</span></span><br></pre></td></tr></table></figure><h4 id="遍历方式-1"><a href="#遍历方式-1" class="headerlink" title="遍历方式"></a>遍历方式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayLisy</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//Collection中的三种遍历方式List均可以复用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//4.普通for循环</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;list.size(); i++)&#123;</span><br><span class="line">    System.out.println(list.get(i));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//列表迭代器ListIterator：遍历时可以添加元素</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="ArrayList源码分析"><a href="#ArrayList源码分析" class="headerlink" title="ArrayList源码分析"></a>ArrayList源码分析</h2><p><img src="C:\Users\wilbur\AppData\Roaming\Typora\typora-user-images\image-20240709172613953.png" alt="image-20240709172613953" style="zoom: 50%;" /></p><h3 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h3><ul><li>利用空参创建的集合，在底层最开始创建一个默认长度为0的名为elementData的数组</li><li>添加第一个元素时，底层会创建一个新的长度为10的数组</li><li>存满时，扩容1.5倍</li><li>如果一次添加多个元素，1.5倍放不下，则新创建数组的长度以实际为准</li></ul><h2 id="LinkedList底层源码"><a href="#LinkedList底层源码" class="headerlink" title="LinkedList底层源码"></a>LinkedList底层源码</h2><p><img src="C:\Users\wilbur\AppData\Roaming\Typora\typora-user-images\image-20240710143823305.png" alt="image-20240710143823305"></p><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>可以在编译阶段约束操作的数据类型，格式&lt;数据类型&gt;，但只支持引用数据类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//没有泛型时</span></span><br><span class="line"><span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();      <span class="comment">//没有泛型的集合</span></span><br><span class="line">list.add(<span class="number">123</span>); <span class="comment">//装箱为Integer</span></span><br><span class="line">list.add(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">list.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">22</span>));     <span class="comment">//可以添加任意引用数据类型</span></span><br><span class="line"><span class="comment">//但是在遍历时，迭代器对象为Object类型，多态下父类对象不能访问子类特有的方法</span></span><br></pre></td></tr></table></figure><p>Java中的泛型是伪泛型，只在编译期间起作用，数据在集合中真正仍为Object对象</p><p>在编译结束的class文件中，泛型全部被擦除，称为泛型擦除</p><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当一个类中，某个变量的数据类型不确定时，就可以定义带有泛型的类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt;&#123; &#125;</span><br></pre></td></tr></table></figure><h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当方法中形参类型不确定时，可以使用类名后定义的泛型&lt;E&gt;， 也可以在方法申明上定义自己的泛型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//方法一：在类中的所有方法均可以使用泛型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt;&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">get</span><span class="params">(E e)</span>&#123;</span><br><span class="line">        system.out.println(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法二：仅在本方法中可以使用泛型</span></span><br><span class="line"><span class="keyword">public</span>&lt;T&gt; <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(T t)</span>&#123; &#125;;</span><br></pre></td></tr></table></figure><h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//与泛型类相似</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">List</span>&lt;E&gt;&#123;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用方式</span></span><br><span class="line"><span class="comment">//1.实现类给出具体类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1</span> inplements List&lt;String&gt;&#123;</span><br><span class="line">    <span class="comment">//重写List接口中的所有抽象方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.实现类延续泛型，创建对象时在确定类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo2</span> inolements List&lt;E&gt;&#123;</span><br><span class="line">    <span class="comment">//重写List接口中的所有抽象方法</span></span><br><span class="line">&#125;</span><br><span class="line">Demo2&lt;String&gt; arr = <span class="keyword">new</span> <span class="title class_">Demo2</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><h3 id="泛型的继承与通配符"><a href="#泛型的继承与通配符" class="headerlink" title="泛型的继承与通配符"></a>泛型的继承与通配符</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//泛型不具备继承性，但是数据具备继承性</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ye</span>&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fu</span> <span class="keyword">extends</span> <span class="title class_">Ye</span>&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Zi</span> <span class="keyword">extends</span> <span class="title class_">Fu</span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(ArratList&lt;Ye&gt; list)</span>&#123;&#125;</span><br><span class="line">    ArrayList&lt;Ye&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    ArrayList&lt;Fu&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    ArrayList&lt;Zi&gt; list3 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//泛型不具备继承多态性,调用method方法时必须传递相应类型的参数</span></span><br><span class="line">    method(list1);</span><br><span class="line">    method(liest2);<span class="comment">//报错</span></span><br><span class="line">    method(list3);<span class="comment">//报错</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//数据具备继承与多态性</span></span><br><span class="line">    list1.add(<span class="keyword">new</span> <span class="title class_">Ye</span>());</span><br><span class="line">    list1.add(<span class="keyword">new</span> <span class="title class_">Fu</span>());</span><br><span class="line">    list1.add(<span class="keyword">new</span> <span class="title class_">Zi</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通配符?</span></span><br><span class="line"><span class="comment">// ? extends E:表示可以传递E或者E所有子类类型</span></span><br><span class="line"><span class="comment">// ? super E:表示可以传递E或者E所有父类类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">(ArratList&lt;? extends Ye&gt; list)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">(ArratList&lt;? <span class="built_in">super</span> Zi&gt; list)</span>&#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><ul><li>无序：存取顺序不一致</li><li>不重复：可以去除重复</li><li>无索引：没有带索引的方法，不能用for循环来遍历，也不能通过[ ]索引来获取元素</li><li>Set是一个接口，其中的方法与Collection的API一致</li></ul><h2 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//哈希值：根据hashCode方法计算v胡来的int类型的整数</span></span><br><span class="line"><span class="comment">//该方法定义在Object类中，所有对象都可以调用，默认使用地址值计算</span></span><br></pre></td></tr></table></figure><h3 id="哈希值的特点"><a href="#哈希值的特点" class="headerlink" title="哈希值的特点"></a>哈希值的特点</h3><ul><li>如果没有重写hashCode方法，不同对象计算出的哈希值时不同的</li><li>重写了hashCode后，只要对象的属性值一样则哈希值也一样( ALT + INSERT快捷键)</li><li>在部分情况下，不同属性值或者不同地址值计算出的哈希值一样，称为哈希冲突</li></ul><h3 id="HashSet底层原理"><a href="#HashSet底层原理" class="headerlink" title="HashSet底层原理"></a>HashSet底层原理</h3><ul><li>HashSet集合底层采取哈希表存储数据</li><li>JDK8以前哈希表由数组+链表组成</li><li>JDK8开始哈希表由数组+链表+红黑树组成</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.创建一个默认长度为16，默认加载因子为0.75的数组，数组名为table</span><br><span class="line">2.根据元素的哈希值跟数组的长度计算出应存入的位置：int index = (数组长度-1) &amp; 哈希值</span><br><span class="line">3.判断当前位置是否为null，如果是null直接存入</span><br><span class="line">4.否则调用equals方法比较属性值</span><br><span class="line">5.一样：不存；不一样：存入数组，形成链表</span><br><span class="line">JDK8以前：老元素挂到新元素下面   JDK8以后：新元素挂到老元素下面</span><br><span class="line"></span><br><span class="line">JDK8以后，当链表长度超过8，且数组长度≥64时，链表自动转换为红黑树</span><br><span class="line">如果集合中存储的是自定义对象，必须重写equals方法和hashCode方法</span><br></pre></td></tr></table></figure><h2 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h2><p>底层基于哈希表，但是使用双链表记录添加顺序</p><h2 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h2><p>元素不重复，无索引，可排序。底层采用红黑树实现</p><h3 id="比较规则："><a href="#比较规则：" class="headerlink" title="比较规则："></a>比较规则：</h3><ul><li>自然排序/默认排序：默认按升序排序；如果TreeSet中存储的元素为自定义对象，需要在JavaBean类中实现Comparable接口指定比较规则</li><li>比较器排序：创建TressSet时，传递比较器Comparator指定规则(利用带参构造传入匿名的Comparator对象)</li></ul><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p><img src="C:\Users\wilbur\AppData\Roaming\Typora\typora-user-images\image-20240712142909097.png" alt="image-20240712142909097"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//常用方法</span></span><br><span class="line">V <span class="title function_">put</span><span class="params">(K key, V value)</span>;              <span class="comment">//添加(覆盖)元素，如果键存在，会覆盖原有键值对，并返回被覆盖的值</span></span><br><span class="line">V <span class="title function_">remove</span><span class="params">(Object key)</span>;               <span class="comment">//根据键删除键值对元素，并返回被删除的值</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span>;                       <span class="comment">//移除所有键值对元素</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">containsKey</span><span class="params">(Object key)</span>;    <span class="comment">//判断集合是否包含指定的键</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">containsValue</span><span class="params">(Object value)</span>;<span class="comment">//判断集合是否包含指定的值</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>;                  <span class="comment">//判空</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>;                         <span class="comment">//计算集合中键值对的个数</span></span><br></pre></td></tr></table></figure><h3 id="遍历方式-2"><a href="#遍历方式-2" class="headerlink" title="遍历方式"></a>遍历方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">map.put(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">22</span>);</span><br><span class="line">map.put(<span class="string">&quot;lsi&quot;</span>, <span class="number">23</span>);</span><br><span class="line">map.put(<span class="string">&quot;wangwu&quot;</span>, <span class="number">24</span>);</span><br><span class="line"><span class="comment">//方法一：获取所有的键，将这些键放在一个单列集合中,遍历每一个键，使用get()得到值</span></span><br><span class="line">Set&lt;String&gt; keys = map.keySet();</span><br><span class="line"><span class="keyword">for</span>(String key:keys)&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法二：通过键值对对象进行遍历，遍历entries集合，获得每一个键值对对象</span></span><br><span class="line">Set&lt;Map.Entry&lt;String, Integer&gt;&gt; entries = map.entrySet();</span><br><span class="line"><span class="keyword">for</span>(Map.Entry&lt;String, Integer&gt; entry : entries)&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">    <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法三：Lambda表达式遍历</span></span><br><span class="line"><span class="comment">//底层原理：利用第二种方法，得到键值对对象，然后调用accept()方法</span></span><br><span class="line">map.forEach((key,value)-&gt;System.out.println(key + <span class="string">&quot;=&quot;</span> + value));</span><br></pre></td></tr></table></figure><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol><li>HashMap底层时哈希表结构</li><li>依赖HashCode( )和equals( )保证键的唯一</li><li>如果键存储的是自定义对象，需要重写HashCode方法和equals方法</li></ol><h2 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h2><ul><li>由键决定：有序，不重复，无索引</li><li>这里的有序指的是存储和取出的元素顺序一致</li><li>原理：底层数据结构仍未哈希表，只是每个键值对元素又额外多了一个双链表的机制记录存储顺序</li></ul><h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><ul><li>TreeMap与TreeSet底层原理一样，也是由红黑树构成的</li><li>由键决定 ：不重复，无索引，可排序，可排序指的是可以根据键进行排序</li><li>与TreeSet一样，可以自己定义比较规则</li></ul><h2 id="HashMap-与-TreeMap底层源码分析"><a href="#HashMap-与-TreeMap底层源码分析" class="headerlink" title="HashMap 与 TreeMap底层源码分析"></a>HashMap 与 TreeMap底层源码分析</h2><h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//格式   属性类型...名字</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getSum</span><span class="params">(<span class="type">int</span>...args)</span>&#123;</span><br><span class="line"><span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> a:args)sum += a;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在方法的形参中最多只能有一个可变参数</span></span><br><span class="line"><span class="comment">//在方法中，如果除了可变参数以外还有其他的形参，可变参数必须放在最后面</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h2><p>集合的工具类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(Collection&lt;T&gt; c, T...elements)</span>;              <span class="comment">//批量添加元素到c中</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">shuffle</span><span class="params">(List&lt;?&gt; list)</span>;                                     <span class="comment">//打乱List集合元素的顺序</span></span><br><span class="line"></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">Collections.addAll(list, <span class="string">&quot;abc&quot;</span>,<span class="string">&quot;bcd&quot;</span>. <span class="string">&quot;qwer&quot;</span>);</span><br><span class="line">Collections.shuffle(list);</span><br></pre></td></tr></table></figure><h2 id="不可变集合"><a href="#不可变集合" class="headerlink" title="不可变集合"></a>不可变集合</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = List.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line">Set&lt;Integer&gt; set = Set.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line"><span class="comment">//Map的不可变集合中最多存储10对键值对,如果要传递多个键值对(&gt;10)，必须传递entry对象;很复杂。。。</span></span><br><span class="line">Map&lt;Integer,String&gt; map = Map.of(<span class="number">1</span>,<span class="string">&quot;李震&quot;</span>,<span class="number">2</span>,<span class="string">&quot;冯鼎智&quot;</span>,<span class="number">3</span>,<span class="string">&quot;卢艺丰&quot;</span>,<span class="number">4</span>,<span class="string">&quot;叶文杰&quot;</span>);</span><br><span class="line">Set&lt;Map.Entry&lt;Integer,String&gt;&gt; entries = map.entrySet();</span><br><span class="line">Map.Entry[] arr1 = <span class="keyword">new</span> <span class="title class_">Map</span>.Entry[<span class="number">0</span>];</span><br><span class="line">Map.Entry[] arr2 = entries.toArray(arr1);</span><br><span class="line"><span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> Map.ofEntries(arr2);</span><br></pre></td></tr></table></figure><h1 id="Stream流"><a href="#Stream流" class="headerlink" title="Stream流"></a>Stream流</h1><p><img src="C:\Users\wilbur\AppData\Roaming\Typora\typora-user-images\image-20240713153322162.png" alt="image-20240713153322162"></p><p>注意：对于Stream接口的中 of 静态方法，传入数组时。若数组的数据类型为基本数据类型，则只会被当成一个元素(数组的地址)存储到Stream中。因此使用该方法时，必须保证of方法里传入的数组类型为引用数据类型</p><h2 id="Stream流的中间方法"><a href="#Stream流的中间方法" class="headerlink" title="Stream流的中间方法"></a>Stream流的中间方法</h2><p><img src="C:\Users\wilbur\AppData\Roaming\Typora\typora-user-images\image-20240713154532833.png" alt="image-20240713154532833" style="zoom:50%;" /></p><p>注意：</p><ul><li>使用distinct方法去重时，如果是对引用数据类型去重，则在类里面一定要重写hashCode方法和equals方法</li><li>使用concat方法合并两个流对象时，若两个流的对象类型不一样，则合并后的类型为两个对象最近的父类对象，因此在使用concat方法时，尽量保证两个流中数据类型一致</li><li>map方法形参中的Function接口中第一个参数为流中原本的数据类型，第二个为需要转换的数据类型(也只能是引用数据类型)</li></ul><h2 id="Stream流的终结方法"><a href="#Stream流的终结方法" class="headerlink" title="Stream流的终结方法"></a>Stream流的终结方法</h2><p><img src="C:\Users\wilbur\AppData\Roaming\Typora\typora-user-images\image-20240713160254757.png" alt="image-20240713160254757"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//toArray()方法</span></span><br><span class="line"><span class="type">String</span> <span class="variable">arr</span> <span class="operator">=</span> list.stream().toArray(<span class="keyword">new</span> <span class="title class_">IntFunction</span>&lt;String[]&gt;)&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] apply(<span class="type">int</span> value)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[value];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Lambda表达式：String arr = list.stream().toArray(value-&gt;new String[value]);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//collet()方法</span></span><br><span class="line">List&lt;String&gt; newlist1=list.stream()</span><br><span class="line">    .filter(s-&gt;<span class="string">&quot;男&quot;</span>.equals(s.split(<span class="string">&quot;-&quot;</span>)[<span class="number">1</span>]))</span><br><span class="line">                               .collect(Collectors.toList());</span><br><span class="line">Set&lt;String&gt; newlist2=list.stream()</span><br><span class="line">    .filter(s-&gt;<span class="string">&quot;男&quot;</span>.equals(s.split(<span class="string">&quot;-&quot;</span>)[<span class="number">1</span>]))</span><br><span class="line">                               .collect(Collectors.toSet());</span><br><span class="line"><span class="comment">//toMap():参数一表示键的生成规则，参数二表示值的生成规则,且键不能重复</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数一：</span></span><br><span class="line"><span class="comment">Function泛型一：表示流中的每一个数据的类型</span></span><br><span class="line"><span class="comment">    泛型二：表示Map集合中键的数据类型</span></span><br><span class="line"><span class="comment"> 方法apply形参：依次表示流中的每个数据</span></span><br><span class="line"><span class="comment"> 方法体：生成键的代码</span></span><br><span class="line"><span class="comment"> 返回值：已经生成的键</span></span><br><span class="line"><span class="comment">参数二：</span></span><br><span class="line"><span class="comment">Function泛型一：表示流中的每一个数据的类型</span></span><br><span class="line"><span class="comment">    泛型二：表示Map集合中值的数据类型</span></span><br><span class="line"><span class="comment"> 方法apply形参：依次表示流中的每个数据</span></span><br><span class="line"><span class="comment"> 方法体：生成值的代码</span></span><br><span class="line"><span class="comment"> 返回值：已经生成的值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Map&lt;String, Integer&gt; map = list.stream()</span><br><span class="line">     .filter(s-&gt;<span class="string">&quot;男&quot;</span>.equals(s.split(<span class="string">&quot;-&quot;</span>)[<span class="number">1</span>]))</span><br><span class="line">     .collect(Collectors.toMap(<span class="keyword">new</span> <span class="title class_">Function</span>&lt;String,Integer&gt;()&#123;</span><br><span class="line">                                 <span class="meta">@Override</span></span><br><span class="line">                                 <span class="keyword">public</span> String <span class="title function_">apply</span><span class="params">(String s)</span>&#123;</span><br><span class="line">                                     <span class="keyword">return</span> s.splite(<span class="string">&quot;-&quot;</span>)[<span class="number">0</span>];</span><br><span class="line">                                 &#125;</span><br><span class="line">                             &#125;,</span><br><span class="line">                                                      <span class="keyword">new</span> <span class="title class_">Function</span>&lt;String,Integer&gt;()&#123;</span><br><span class="line">                                                          <span class="meta">@Override</span></span><br><span class="line">                                                          <span class="keyword">public</span> String <span class="title function_">apply</span><span class="params">(String s)</span>&#123;</span><br><span class="line">                                                              <span class="keyword">return</span> Integer.parseInt(s.splite(<span class="string">&quot;-&quot;</span>)[<span class="number">2</span>]);</span><br><span class="line">                                                          &#125;</span><br><span class="line">                                                      &#125;))</span><br></pre></td></tr></table></figure><h2 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h2><ol><li>需要有函数式接口</li><li>被引用的方法必须存在</li><li>方法的形参和返回值需要与抽象方法/接口的形参与返回值一样</li><li>被引用方法的功能需要满足当前的需求</li></ol><ul><li>引用静态方法</li><li>引用成员方法</li><li>引用构造方法</li><li>引用其他的方法</li></ul><h3 id="引用静态方法"><a href="#引用静态方法" class="headerlink" title="引用静态方法"></a>引用静态方法</h3><p>类名::静态方法名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例子：集合中有字符串1，2，3，4，5要求将他们变为int类型</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">Collections.addAll(list,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;3&quot;</span>,<span class="string">&quot;4&quot;</span>,<span class="string">&quot;5&quot;</span>);</span><br><span class="line">list.stream().map(<span class="keyword">new</span> <span class="title class_">Function</span>&lt;String,Integer&gt;()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="type">int</span> i=Integer.parseInt(s);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;).forEach(s -&gt; system.out.println(s));</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法引用</span></span><br><span class="line">list.stream().map(Integer::parseInt).forEach(s -&gt; system.out.println(s));</span><br></pre></td></tr></table></figure><h3 id="引用成员方法"><a href="#引用成员方法" class="headerlink" title="引用成员方法"></a>引用成员方法</h3><p>对象::成员方法</p><ul><li>其他类：其它类对象::方法名</li><li>本类：this::方法名</li><li>父类：super:方法名</li></ul><h3 id="引用构造方法"><a href="#引用构造方法" class="headerlink" title="引用构造方法"></a>引用构造方法</h3><p>类名::new</p><h3 id="其他引用方法"><a href="#其他引用方法" class="headerlink" title="其他引用方法"></a>其他引用方法</h3><ul><li>类名引用成员方法：类名：方法名  eg. String::toUpperCase</li><li>引用数组的构造方法：数据类型[]::new   eg.int[ ]::new</li></ul><h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><p><img src="C:\Users\wilbur\AppData\Roaming\Typora\typora-user-images\image-20240714152409990.png" alt="image-20240714152409990"></p><h2 id="异常的作用"><a href="#异常的作用" class="headerlink" title="异常的作用"></a>异常的作用</h2><ol><li>查询相关bug的关键参考信息</li><li>异常可以作为方法内部的一种特殊返回值，以便通知调用者底层的执行情况</li></ol><h2 id="JVM默认的处理方式"><a href="#JVM默认的处理方式" class="headerlink" title="JVM默认的处理方式"></a>JVM默认的处理方式</h2><ul><li>把异常的名称，异常原因以及异常出现的位置等信息输出在控制台</li><li>程序停止执行，下面的代码不会继续执行</li></ul><h2 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//可能出现异常的代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类名 变量名)&#123;</span><br><span class="line">   <span class="comment">// 异常处理的代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//catch之后的代码也会被执行</span></span><br></pre></td></tr></table></figure><h3 id="如果try中出现了多个问题，如何执行？"><a href="#如果try中出现了多个问题，如何执行？" class="headerlink" title="如果try中出现了多个问题，如何执行？"></a>如果try中出现了多个问题，如何执行？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    system.out.println(arr[<span class="number">10</span>]);           <span class="comment">//抛出ArrayIndexOutOfBoundsException</span></span><br><span class="line">    system.out.println(<span class="number">10</span> / <span class="number">0</span>);       <span class="comment">//抛出ArithmeticException</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(ArrayIndexOutOfBoundsException e)&#123;</span><br><span class="line">    system.out.println(<span class="string">&quot;数组越界错误&quot;</span>);</span><br><span class="line">&#125;<span class="comment">//catch(ArithmeticException e)&#123;</span></span><br><span class="line"><span class="comment">//system.out.println(&quot;整数除零错误&quot;);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//如果没有写多个catch捕获异常，则在try中出现第一个异常后，下面的代码都不会执行</span></span><br><span class="line"><span class="comment">//如果多个异常存在父子关系，那么父类一定要写在下面</span></span><br></pre></td></tr></table></figure><h3 id="如果try中抛出的-异常没有被catch捕获到，如何执行"><a href="#如果try中抛出的-异常没有被catch捕获到，如何执行" class="headerlink" title="如果try中抛出的 异常没有被catch捕获到，如何执行"></a>如果try中抛出的 异常没有被catch捕获到，如何执行</h3><p>按照JVM的默认方式处理该异常</p><h3 id="如果try中遇到了异常，那么try中该异常下面的代码会执行吗？"><a href="#如果try中遇到了异常，那么try中该异常下面的代码会执行吗？" class="headerlink" title="如果try中遇到了异常，那么try中该异常下面的代码会执行吗？"></a>如果try中遇到了异常，那么try中该异常下面的代码会执行吗？</h3><p>下面的代码不会执行，程序直接跳转到相应的catch中执行，若没有匹配的catch，则默认交给jvm处理</p><h2 id="异常的常见方法"><a href="#异常的常见方法" class="headerlink" title="异常的常见方法"></a>异常的常见方法</h2><p><img src="C:\Users\wilbur\AppData\Roaming\Typora\typora-user-images\image-20240714160941486.png" alt="image-20240714160941486"></p><p>一般只用printStackTrace()方法</p><h2 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//throws:写在方法定义处，告诉调用者，使用该方法可能会出现哪些错误</span></span><br><span class="line"><span class="comment">//throw:写在方法内，结束方法，手动抛出异常，交给调用者，下面的代码不再执行</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getMax</span><span class="params">(<span class="type">int</span>[] arr)</span><span class="comment">/* throws NullPointerException, ArrayIndexOutOfBoundsException */</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr == <span class="literal">null</span>)<span class="keyword">throw</span> NullPointerException();</span><br><span class="line">    <span class="keyword">if</span>(arr.length == <span class="number">0</span>)<span class="keyword">throw</span> ArrayIndexOutOfBoundsException();</span><br><span class="line">    <span class="type">int</span> max=arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i:arr) max = Math.max(max,i);</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span>[] arr = <span class="literal">null</span>;</span><br><span class="line"><span class="type">int</span> max=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    max = getMax(arr);</span><br><span class="line">&#125;<span class="keyword">catch</span>(NullPointerException e)&#123;</span><br><span class="line">    system.out.println(<span class="string">&quot;空指针异常&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span>(ArrayIndexOutOfBoundsException e)&#123;</span><br><span class="line">    system.out.println(<span class="string">&quot;数组越界异常&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">system.out.println(max);</span><br></pre></td></tr></table></figure><h2 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h2><ol><li>定义异常类：类名需要见名知义</li><li>写继承关系：运行时异常继承RunTimeException,否则直接继承Exception</li><li>写空参构造</li><li>写带参构造</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NameFormatException</span> <span class="keyword">extends</span> <span class="title class_">RunTimeException</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NameFormatException</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NameFormatException</span><span class="params">(String message)</span>&#123;</span><br><span class="line">        <span class="comment">//传入的message即为我们想输出在控制台的报错信息</span></span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="File"><a href="#File" class="headerlink" title="File"></a>File</h1><p>File类只能对文件本身进行操作，不能读写文件里面的内容</p><p><img src="C:\Users\wilbur\AppData\Roaming\Typora\typora-user-images\image-20240715140401129.png" alt="image-20240715140401129"></p><p>注意：在路径”C:\Users\Public\Desktop\QQ.lnk”中，父级路径是指C:\Users\Public\Desktop\ 这一部分，子级路径是指 QQ.lnk 这一部分</p><h2 id="File类的常见成员方法"><a href="#File类的常见成员方法" class="headerlink" title="File类的常见成员方法"></a>File类的常见成员方法</h2><p><img src="C:\Users\wilbur\AppData\Roaming\Typora\typora-user-images\image-20240715140850922.png" alt="image-20240715140850922"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意：length()方法只能获取文件的大小，无法获取文件夹的大小</span></span><br></pre></td></tr></table></figure><p><img src="C:\Users\wilbur\AppData\Roaming\Typora\typora-user-images\image-20240715141627358.png" alt="image-20240715141627358"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//createNewFile()方法：如果当前文件路径下不存在该文件，则创建成功。否则，创建失败，父级路径若不存在也会报错IOException</span></span><br><span class="line"><span class="comment">//createNewFile()创建的一定是文件，而不是文件夹</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//windows当中路径是唯一的，如果当前路径已经存在，则无法创建新的文件夹</span></span><br><span class="line"><span class="comment">//mkdir()只能创建单击文件夹，若父级路径中某些文件夹不存在，则会创建失败</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//delete()方法，若删除的是空文件或者空文件夹，则直接删除不走回收站；若删除的是有内容的文件夹，会删除失败</span></span><br></pre></td></tr></table></figure><p><img src="C:\Users\wilbur\AppData\Roaming\Typora\typora-user-images\image-20240715143319175.png" alt="image-20240715143319175"></p><h2 id="获取并遍历的方法"><a href="#获取并遍历的方法" class="headerlink" title="获取并遍历的方法"></a>获取并遍历的方法</h2><p><img src="C:\Users\wilbur\AppData\Roaming\Typora\typora-user-images\image-20240715143429384.png" alt="image-20240715143429384"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//listRoots()只能获取盘符</span></span><br><span class="line">File[] arr = File.listRoots();</span><br><span class="line">System.out.println(arr);     <span class="comment">//打印：[C:\,D:\,E:\]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//list()只能获取当前路径下所有文件和文件夹的名称</span></span><br><span class="line"><span class="type">File</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;路径&quot;</span>);</span><br><span class="line">String[] arr2 = f1.list();</span><br><span class="line"><span class="keyword">for</span>(String s: arr2)System.out.println(s);</span><br></pre></td></tr></table></figure><h1 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h1><p>IO流用于读写文件中的数据，可以读写文件，或者网络中的数据</p><p><img src="C:\Users\wilbur\AppData\Roaming\Typora\typora-user-images\image-20240715151129211.png" alt="image-20240715151129211" style="zoom:50%;" /></p><h2 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h2><p><img src="C:\Users\wilbur\AppData\Roaming\Typora\typora-user-images\image-20240715151306242.png" alt="image-20240715151306242" style="zoom:50%;" /></p><h2 id="FileOutputStream"><a href="#FileOutputStream" class="headerlink" title="FileOutputStream"></a>FileOutputStream</h2><p>操作本地文件的字节输出流，可以把程序中的数据写到本地文件中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//书写步骤</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.创建对象</span></span><br><span class="line"><span class="comment">/*细节1：参数是字符串表示的路径或者是File对象都是可以的</span></span><br><span class="line"><span class="comment"> 细节2：如果文件不存在会创建一个新的空的文件，但要保证其父级路径是存在的</span></span><br><span class="line"><span class="comment"> 细节3：如果文件已经存在，则会清空文件</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;myio\\a.txt&quot;</span>);  </span><br><span class="line"></span><br><span class="line"><span class="comment">//2.写出数据</span></span><br><span class="line"><span class="comment">/*细节1：write方法的参数是整数，但实际上写到本地文件中的是整数在ASCII码上对应的字符</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">fos.write(<span class="number">97</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.释放资源:解除对该文件的占用,每次写完必须释放</span></span><br><span class="line">fos.close();</span><br></pre></td></tr></table></figure><h3 id="FileOutputStream写数据的3中方法"><a href="#FileOutputStream写数据的3中方法" class="headerlink" title="FileOutputStream写数据的3中方法"></a>FileOutputStream写数据的3中方法</h3><p><img src="C:\Users\wilbur\AppData\Roaming\Typora\typora-user-images\image-20240715152657151.png" alt="image-20240715152657151" style="zoom: 67%;" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;myio\\a.txt&quot;</span>);</span><br><span class="line"><span class="comment">//1.方法一</span></span><br><span class="line">fos.write(<span class="number">97</span>);</span><br><span class="line">fos.write(<span class="number">98</span>);</span><br><span class="line"><span class="comment">//方法二</span></span><br><span class="line"><span class="type">byte</span>[] bytes = &#123;<span class="number">97</span>,<span class="number">98</span>,<span class="number">99</span>,<span class="number">100</span>,<span class="number">101</span>&#125;;</span><br><span class="line">fos.write(bytes);</span><br><span class="line"><span class="comment">//方法三</span></span><br><span class="line">fos.write(bytes, <span class="number">1</span>, <span class="number">2</span>);      <span class="comment">//从索引为1的地方开始写入两个字节的数据，结果就是bc</span></span><br><span class="line">fos.close();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//换行写Demo</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">两次写入中间加入一个换行符即可</span></span><br><span class="line"><span class="comment">windows: \r\n</span></span><br><span class="line"><span class="comment">linux:\n</span></span><br><span class="line"><span class="comment">mac:\r</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;myio\\a.txt&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;lizhenhaoshuai&quot;</span>;</span><br><span class="line"><span class="type">byte</span>[] byte1 = str.getBytes();</span><br><span class="line">fos.write(byte1);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">wrap</span> <span class="operator">=</span> <span class="string">&quot;\r\n&quot;</span>;</span><br><span class="line"><span class="type">byte</span>[] wraps = wrap.getBytes();</span><br><span class="line">fos.write(wraps);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;666&quot;</span>;</span><br><span class="line"><span class="type">byte</span>[] byte2 = str.getBytes();</span><br><span class="line">fos.write(byte2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//续写Demo</span></span><br><span class="line"><span class="comment">//创建FileOutputStream对象时，传入true打开续写开关。打开续写开关后，再次写入时，不会清空</span></span><br><span class="line"><span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;myio\\a.txt&quot;</span>, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure><h2 id="FileInputStream"><a href="#FileInputStream" class="headerlink" title="FileInputStream"></a>FileInputStream</h2><p>操作本地文件的字节输入流，可以把本地文件中的数据读取到程序中来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//书写步骤</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.创建对象</span></span><br><span class="line"><span class="comment">//细节1：如果文件不存在，会直接报错</span></span><br><span class="line"></span><br><span class="line"><span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;myio\\a.txt&quot;</span>);  <span class="comment">//假设该文件中的数据为abcde</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.读取数据</span></span><br><span class="line"><span class="comment">/*细节1：read()方法是一字节一字节读取数据，如果读取不到数据了会返回-1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="variable">b1</span> <span class="operator">=</span> fis.read(); <span class="comment">//读取一字节的数据，结果为97(a对应的ASCII码)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3.释放资源:解除对该文件的占用,每次用必须释放</span></span><br><span class="line">fos.close();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//循环读取</span></span><br><span class="line"><span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;myio\\a.txt&quot;</span>); </span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line"><span class="keyword">while</span>((b = fis.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">    System.out.println((<span class="type">char</span>)b);</span><br><span class="line">&#125;</span><br><span class="line">fis.close();</span><br></pre></td></tr></table></figure><p><img src="C:\Users\wilbur\AppData\Roaming\Typora\typora-user-images\image-20240715164915746.png" alt="image-20240715164915746"></p><p> 注意，使用字节数组读取数据时，返回值表示的是此次读取了多少字节的数据，当数组没被读满时，只有前面的数据会被覆盖</p><p>eg. buffer长度为2，读取abcde，第一次读完后buffer内存储的是ab，第二次是cd，第三次只能读出一个e，这个e将c覆盖，因此此时buffer里存储的是ed</p><p><img src="C:\Users\wilbur\AppData\Roaming\Typora\typora-user-images\image-20240716141511643.png" alt="image-20240716141511643"></p><h2 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h2><p><img src="C:\Users\wilbur\AppData\Roaming\Typora\typora-user-images\image-20240716142651201.png" alt="image-20240716142651201"></p><h3 id="GBK字符集"><a href="#GBK字符集" class="headerlink" title="GBK字符集"></a>GBK字符集</h3><ul><li>GBK字符集完全兼容ASCII字符集</li><li>一个英文占一个字节，二进制第一位是0</li><li>一个中文占两个字节，二进制高位字节的第一位是1</li></ul><h3 id="Unicode字符集"><a href="#Unicode字符集" class="headerlink" title="Unicode字符集"></a>Unicode字符集</h3><p><img src="C:\Users\wilbur\AppData\Roaming\Typora\typora-user-images\image-20240716143924727.png" alt="image-20240716143924727" style="zoom:50%;" /></p><h2 id="Java中编码与解码的方法"><a href="#Java中编码与解码的方法" class="headerlink" title="Java中编码与解码的方法"></a>Java中编码与解码的方法</h2><p><img src="C:\Users\wilbur\AppData\Roaming\Typora\typora-user-images\image-20240716144833781.png" alt="image-20240716144833781"></p><h2 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h2><ul><li>字符流的底层其实还是字节流</li><li>输入流：一次读取一个字节，遇到中文时，一次读取多个字节</li><li>输出流：底层会把数据按照指定的编码方式进行编码，变成字节再写到文件中</li></ul><p><img src="C:\Users\wilbur\AppData\Roaming\Typora\typora-user-images\image-20240716145811061.png" alt="image-20240716145811061"></p><h2 id="FileReader"><a href="#FileReader" class="headerlink" title="FileReader"></a>FileReader</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建对象</span></span><br><span class="line"><span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;myio\\a.txt&quot;</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">//2.读取数据(与字节流的read()方法一模一样)</span></span><br><span class="line"><span class="comment">//细节：</span></span><br><span class="line"><span class="comment">//read()方法默认也是一个字节一个字节读取，如果读取到中文则会则读取多个</span></span><br><span class="line"><span class="comment">//在读取之后，方法的底层还会进行解码并转成十进制，把这个十进制值作为返回值</span></span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line"><span class="keyword">while</span>((b == fr.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">    System.out.println((<span class="type">char</span>)ch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.释放资源</span></span><br><span class="line">fr.close();</span><br></pre></td></tr></table></figure><p><img src="C:\Users\wilbur\AppData\Roaming\Typora\typora-user-images\image-20240716154424937.png" alt="image-20240716154424937"></p><h2 id="FileWriter"><a href="#FileWriter" class="headerlink" title="FileWriter"></a>FileWriter</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">FileWriter</span><span class="params">(File file)</span>;              <span class="comment">//创建字符输出流关联本地文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">FileWriter</span><span class="params">(String pathname)</span>;        </span><br><span class="line"><span class="keyword">public</span> <span class="title function_">FileWriter</span><span class="params">(File file, <span class="type">boolean</span> append)</span>; <span class="comment">//创建字符输出流关联本地文件,续写</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">FileWriter</span><span class="params">(String filename, <span class="type">boolean</span> append)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//成员方:write()方法的参数如果是整数，实际上写到文件中的是整数在字符集上对应的字符</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> c)</span>;               <span class="comment">//写出一个字符</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">write</span><span class="params">(String str)</span>;          <span class="comment">//写出一个字符串</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">write</span><span class="params">(String str, <span class="type">int</span> off, <span class="type">int</span> len)</span>; <span class="comment">//写出一个字符串的一部分</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">char</span>[] cbuf)</span>;         <span class="comment">//写出一个字符数组</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">char</span>[] cbuf, <span class="type">int</span> off, <span class="type">int</span> len)</span>; <span class="comment">//写出字符数组的一部分</span></span><br></pre></td></tr></table></figure><h1 id="高级流-IO基本流的拓展"><a href="#高级流-IO基本流的拓展" class="headerlink" title="高级流(IO基本流的拓展)"></a>高级流(IO基本流的拓展)</h1><h2 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h2><p><img src="C:\Users\wilbur\AppData\Roaming\Typora\typora-user-images\image-20240717140325937.png" alt="image-20240717140325937"></p><h3 id="字节缓冲流"><a href="#字节缓冲流" class="headerlink" title="字节缓冲流"></a>字节缓冲流</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;myio\\a.txt&quot;</span>));</span><br><span class="line"><span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;myio\\copy.txt&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//一次copy多个字节</span></span><br><span class="line"><span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="type">int</span> len;</span><br><span class="line"><span class="keyword">while</span>((len=bis.read(bytes)) != -<span class="number">1</span>)&#123;</span><br><span class="line">bos.write(bytes,<span class="number">0</span>,len);</span><br><span class="line">&#125;</span><br><span class="line">bis.close();</span><br><span class="line">bos.close();</span><br></pre></td></tr></table></figure><h3 id="字节缓冲流提高效率的原理"><a href="#字节缓冲流提高效率的原理" class="headerlink" title="字节缓冲流提高效率的原理"></a>字节缓冲流提高效率的原理</h3><p><img src="C:\Users\wilbur\AppData\Roaming\Typora\typora-user-images\image-20240717141737665.png" alt="image-20240717141737665"></p><h3 id="字符缓冲流"><a href="#字符缓冲流" class="headerlink" title="字符缓冲流"></a>字符缓冲流</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字符缓冲流特有的方法</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">readLine</span><span class="params">()</span>;                 <span class="comment">//读取一行数据，如果没有数据可读了，返回null</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">newLine</span><span class="params">()</span>;                    <span class="comment">//跨平台的换行</span></span><br><span class="line"></span><br><span class="line"><span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;myio\\.txt&quot;</span>));</span><br><span class="line">String line;</span><br><span class="line"><span class="keyword">while</span>((line=br.readLine()) != <span class="literal">null</span>)&#123;</span><br><span class="line">    System.out.println(line);</span><br><span class="line">&#125;</span><br><span class="line">br.close();</span><br></pre></td></tr></table></figure><h2 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h2><p><img src="C:\Users\wilbur\AppData\Roaming\Typora\typora-user-images\image-20240717143204648.png" alt="image-20240717143204648"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//利用转换流实现按照指定字符编码读取</span></span><br><span class="line"><span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;myio\\gbkfile.txt&quot;</span>), <span class="string">&quot;GBK&quot;</span>); <span class="comment">//第二个参数指定编码方式读取.目前已经被淘汰</span></span><br><span class="line"><span class="comment">// JDK11之后，字符流的新构造方法</span></span><br><span class="line"><span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReadr</span>(<span class="string">&quot;myio\\gbkfile.txt&quot;</span>, Charset.forname(<span class="string">&quot;GBK&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//利用转换流实现按照指定字符编码写出</span></span><br><span class="line"><span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;myio\\c.txt&quot;</span>, Charset.forname(<span class="string">&quot;GBK&quot;</span>));</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="序列化流-对象操作输出流"><a href="#序列化流-对象操作输出流" class="headerlink" title="序列化流/对象操作输出流"></a>序列化流/对象操作输出流</h2><p><img src="C:\Users\wilbur\AppData\Roaming\Typora\typora-user-images\image-20240717150431890.png" alt="image-20240717150431890" style="zoom: 67%;" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ObjectOutoutStream</span><span class="params">(OutputStream out)</span>;       <span class="comment">//把基本流包装为高级流</span></span><br><span class="line"><span class="comment">//成员方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">writeObject</span><span class="params">(Object obj)</span>;         <span class="comment">//把对象序列化(写出)到文件中去</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//细节：使用对象输出流将对象保存到文件时会出现NotSerializableException异常，必须要让这个对象类实现Serializable接口</span></span><br><span class="line"><span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">23</span>);         <span class="comment">//这里Student必须实现Serializable接口才能序列化</span></span><br><span class="line"><span class="type">ObjectOutoutStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutoutStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;myio\\a.txt&quot;</span>));</span><br><span class="line">oos.writeObject(stu);</span><br><span class="line">oos.close();</span><br></pre></td></tr></table></figure><h2 id="反序列化流-对象操作输入流"><a href="#反序列化流-对象操作输入流" class="headerlink" title="反序列化流/对象操作输入流"></a>反序列化流/对象操作输入流</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ObjectInputStream</span><span class="params">(InputStream in)</span>;           <span class="comment">//把基本流包装为高级流</span></span><br><span class="line"><span class="comment">//成员方法</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">readObject</span><span class="params">()</span>;                         <span class="comment">//把序列化到本地文件中的对象，读取到程序中来</span></span><br><span class="line"></span><br><span class="line"><span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;myio\\a.txt&quot;</span>));</span><br><span class="line"><span class="comment">//Object o = ois.readObject();</span></span><br><span class="line"><span class="type">Student</span> <span class="variable">o</span> <span class="operator">=</span> (Student)ois.readObject();  <span class="comment">//强转</span></span><br><span class="line">System.out.println(o);</span><br><span class="line">ois.close();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.当对象中的属性，方法发生变化时，需要添加serialVersionUID来保证对象能够正常被反序列化</span></span><br><span class="line"><span class="comment">//2.当我们不想序列化对象中的某些属性时，用transient关键字修饰该变量即可.标记后该成员变量不参与序列化过程</span></span><br></pre></td></tr></table></figure><h2 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h2><p>只有输出流，分为字节输出流PrintStream, 和 PrintWriter两个类</p><h3 id="字节打印流-—-底层没有缓冲区，自动刷新"><a href="#字节打印流-—-底层没有缓冲区，自动刷新" class="headerlink" title="字节打印流 — 底层没有缓冲区，自动刷新"></a>字节打印流 — 底层没有缓冲区，自动刷新</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">PrintStream</span><span class="params">(OutputStream / File / String)</span>;           <span class="comment">//关联字节输出流/文件/文件路径</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">PrintStream</span><span class="params">(String filename, Charset charset)</span>;       <span class="comment">//指定字符编码</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">PrintStream</span><span class="params">(OutputStream out, <span class="type">boolean</span> autoFlush)</span>;    <span class="comment">//自动刷新</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">PrintStream</span><span class="params">(OutputStream out, <span class="type">boolean</span> autoFlush, Charset charset)</span>;  <span class="comment">//指定字符编码且自动刷新</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//成员方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> b)</span>;              <span class="comment">//常规方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">println</span><span class="params">(X x)</span>;              <span class="comment">//打印任意数据，自动刷新，自动换行</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(X x)</span>;  <span class="comment">//打印任意数据，不换行</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printf</span><span class="params">(String format, ....)</span>;<span class="comment">//带占位符的打印语句，如%d，%s...不换行</span></span><br></pre></td></tr></table></figure><h3 id="字符打印流-—-底层有缓冲区，想要自动刷新需要手动开启"><a href="#字符打印流-—-底层有缓冲区，想要自动刷新需要手动开启" class="headerlink" title="字符打印流 — 底层有缓冲区，想要自动刷新需要手动开启"></a>字符打印流 — 底层有缓冲区，想要自动刷新需要手动开启</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">PrintWriter</span><span class="params">(Writer / File / String)</span>;           <span class="comment">//关联字节输出流/文件/文件路径</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">PrintWriter</span><span class="params">(String filename, Charset charset)</span>;       <span class="comment">//指定字符编码</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">PrintWriter</span><span class="params">(Writer w, <span class="type">boolean</span> autoFlush)</span>;    <span class="comment">//自动刷新</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">PrintWriter</span><span class="params">(OutputStream out, <span class="type">boolean</span> autoFlush, Charset charset)</span>;  <span class="comment">//指定字符编码且自动刷新</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//成员方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> b)</span>;              <span class="comment">//常规方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">println</span><span class="params">(X x)</span>;              <span class="comment">//打印任意数据，自动刷新，自动换行</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(X x)</span>;  <span class="comment">//打印任意数据，不换行</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printf</span><span class="params">(String format, ....)</span>;<span class="comment">//带占位符的打印语句，如%d，%s...不换行</span></span><br></pre></td></tr></table></figure><h2 id="压缩流"><a href="#压缩流" class="headerlink" title="压缩流"></a>压缩流</h2><p><img src="C:\Users\wilbur\AppData\Roaming\Typora\typora-user-images\image-20240718145816952.png" alt="image-20240718145816952" style="zoom:67%;" /></p><p>压缩包中的每一个文件，都是一个ZipEntry对象</p><p>解压的本质：就是把每一个ZipEntry对象按照层级拷贝到本地另一个文件夹中</p><p>压缩的本质：把每一个文件/文件夹 看成ZipEntry对象放入压缩包中</p><h3 id="解压缩流"><a href="#解压缩流" class="headerlink" title="解压缩流"></a>解压缩流</h3><h3 id="压缩流-1"><a href="#压缩流-1" class="headerlink" title="压缩流"></a>压缩流</h3><h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="启动线程的三种方式"><a href="#启动线程的三种方式" class="headerlink" title="启动线程的三种方式"></a>启动线程的三种方式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//多线程的第一种启动方式</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.自己定义一个类继承Thread 2.重写run方法 3.创建子类对象，启动线程(start方法而不是run方法)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//书写线程要执行的代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">MyThread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line"><span class="type">MyThread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//多线程的第二种启动方式</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.自己定义一个类实现Runnable接口 2.重写run方法 3.创建自己的类对象 4.创建一个Thread类的对象，并开启线程</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRun</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//书写线程要执行的代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">MyRun</span> <span class="variable">mr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRun</span>();</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(mr);</span><br><span class="line">t1.start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//多线程的第三种启动方式</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.创建一个自定义类MyCallable类，实现Callable接口</span></span><br><span class="line"><span class="comment">2.重写call方法，该方法是有返回值的，表示多线程运行的结果</span></span><br><span class="line"><span class="comment">3.创建MyCallable的对象（表示多线程要执行的任务）</span></span><br><span class="line"><span class="comment">4.创建FutureTask的对象（作用管理多线程运行的结果）</span></span><br><span class="line"><span class="comment">5.创建Thread类的对象，并启动（表示线程）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt;&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">100</span>; i++)sum+=i;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">MyCallalbe</span> <span class="variable">mc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyCallalbe</span>();  <span class="comment">//创建MyCallable的对象（表示多线程要执行的任务）</span></span><br><span class="line">FutrueTask&lt;Integer&gt; ft = <span class="keyword">new</span> <span class="title class_">FutrueTask</span>&lt;&gt;(mc); <span class="comment">//创建FutrueTask的对象（作用管理多线程运行的结果）</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ft);</span><br><span class="line">t1.start();</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="常见的成员方法"><a href="#常见的成员方法" class="headerlink" title="常见的成员方法"></a>常见的成员方法</h2><p><img src="C:\Users\wilbur\AppData\Roaming\Typora\typora-user-images\image-20240801152545051.png" alt="image-20240801152545051"></p><h3 id="守护线程：当非守护线程结束后，守护进程会陆陆续续结束"><a href="#守护线程：当非守护线程结束后，守护进程会陆陆续续结束" class="headerlink" title="守护线程：当非守护线程结束后，守护进程会陆陆续续结束"></a>守护线程：当非守护线程结束后，守护进程会陆陆续续结束</h3><h2 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h2><p><img src="C:\Users\wilbur\AppData\Roaming\Typora\typora-user-images\image-20240801154827871.png" alt="image-20240801154827871"></p><h2 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Demo:三个窗口共同售出100张票</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> ticket=<span class="number">0</span>; <span class="comment">//static修饰表示这个类所有对象都贡献ticket变量</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line"><span class="keyword">synchronized</span>(MyThread.class)&#123;<span class="comment">//锁对象一定要是唯一的，一般使用类的字节码对象</span></span><br><span class="line">                <span class="keyword">if</span>(ticket &lt; <span class="number">100</span>)&#123;</span><br><span class="line">   ticket++;</span><br><span class="line">                      System.out.println(getName() + <span class="string">&quot;正在卖第&quot;</span> + ticket + <span class="string">&quot;张票 !!!&quot;</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h2><p><img src="C:\Users\wilbur\AppData\Roaming\Typora\typora-user-images\image-20240802142317033.png" alt="image-20240802142317033"></p><h2 id="Lock锁"><a href="#Lock锁" class="headerlink" title="Lock锁"></a>Lock锁</h2><p><img src="C:\Users\wilbur\AppData\Roaming\Typora\typora-user-images\image-20240802143219732.png" alt="image-20240802143219732"></p><p>注意：类中的锁对象一般要用static修饰，表示唯一的锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">lock.lock();</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(ticket == <span class="number">100</span>)<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                    ticket++;</span><br><span class="line">                    Systen.out.println(<span class="string">&quot;....&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="生产者消费者同步问题"><a href="#生产者消费者同步问题" class="headerlink" title="生产者消费者同步问题"></a>生产者消费者同步问题</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//常见方法</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">wait</span><span class="params">()</span>;   <span class="comment">//阻塞当前进程，直到被其他线程唤醒</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">notify</span><span class="params">()</span>; <span class="comment">//随机唤醒单个线程，具有随机性</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">notifyAll</span><span class="params">()</span>; <span class="comment">//唤醒所有线程</span></span><br></pre></td></tr></table></figure><h2 id="阻塞队列的继承结构"><a href="#阻塞队列的继承结构" class="headerlink" title="阻塞队列的继承结构"></a>阻塞队列的继承结构</h2><p><img src="C:\Users\wilbur\AppData\Roaming\Typora\typora-user-images\image-20240802152844514.png" alt="image-20240802152844514"></p><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Executors:线程池的工具类通过调用方法返回不同类型的线程池对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span>; <span class="comment">//创建一个没有上限/上限为int最大的线程池</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads)</span>; <span class="comment">// 创建有上限的线程池</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.获取线程池对象</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">pool1</span> <span class="operator">=</span> Executor.newCachedThreadPool();</span><br><span class="line"><span class="comment">//2.提交任务</span></span><br><span class="line">pool1.submit(任务<span class="number">1</span>);</span><br><span class="line">pool1.submit(任务<span class="number">2</span>);</span><br><span class="line">pool1.submit(任务<span class="number">3</span>);</span><br><span class="line">pool1.submit(任务<span class="number">4</span>);</span><br><span class="line"><span class="comment">//3.销毁线程池（一般不销毁）</span></span><br><span class="line"><span class="comment">//pool1.shutdowm();</span></span><br></pre></td></tr></table></figure><h3 id="线程池有原理"><a href="#线程池有原理" class="headerlink" title="线程池有原理"></a>线程池有原理</h3><p><img src="C:\Users\wilbur\AppData\Roaming\Typora\typora-user-images\image-20240802160157439.png" alt="image-20240802160157439" style="zoom:50%;" /></p><h2 id="自定义线程池"><a href="#自定义线程池" class="headerlink" title="自定义线程池"></a>自定义线程池</h2><h3 id="构造方法中7个参数的含义"><a href="#构造方法中7个参数的含义" class="headerlink" title="构造方法中7个参数的含义"></a>构造方法中7个参数的含义</h3><p><img src="C:\Users\wilbur\AppData\Roaming\Typora\typora-user-images\image-20240802161500281.png" alt="image-20240802161500281" style="zoom:33%;" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ThreadPoolExecutor</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line"><span class="number">3</span>,  <span class="comment">//核心线程数量，不能小于0</span></span><br><span class="line"><span class="number">6</span>,  <span class="comment">//最大线程数，不能小于0，且最大数量 &gt;= 核心线程数, 根据这个可以计算出临时线程的数量</span></span><br><span class="line">    <span class="number">60</span>, <span class="comment">//空闲(的临时)线程最大存活时间</span></span><br><span class="line">    TimeUnit.SECONDS, <span class="comment">//空闲时间的单位</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">3</span>), <span class="comment">//阻塞队列</span></span><br><span class="line">    Executors.defaultThreadFactory(), <span class="comment">//创建线程工厂</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy() <span class="comment">//任务的拒绝策略</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ol><li>创建一个空的线程池</li><li>有任务提交时，线程池会创建线程去执行任务，执行完毕归还线程</li><li>当核心线程满时，再提交任务就会排队阻塞</li><li>当核心线程满，阻塞队列满时，会创建临时线程</li><li>当核心线程满，阻塞队列满，临时线程满时，会触发任务拒绝策略</li></ol><p><img src="C:\Users\wilbur\AppData\Roaming\Typora\typora-user-images\image-20240802161401597.png" alt="image-20240802161401597" style="zoom:33%;" /></p><h3 id="任务拒绝策略"><a href="#任务拒绝策略" class="headerlink" title="任务拒绝策略"></a>任务拒绝策略</h3><p><img src="C:\Users\wilbur\AppData\Roaming\Typora\typora-user-images\image-20240802161417165.png" alt="image-20240802161417165" style="zoom:50%;" /></p><h3 id="自定义线程池的大小"><a href="#自定义线程池的大小" class="headerlink" title="自定义线程池的大小"></a>自定义线程池的大小</h3><p><img src="C:\Users\wilbur\AppData\Roaming\Typora\typora-user-images\image-20240802164656285.png" alt="image-20240802164656285" style="zoom:33%;" /></p><h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">InetAddress</span> <span class="variable">address</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;LAPTOP-BEA61MHQ&quot;</span>);</span><br><span class="line">System.out.println(address);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> address.getHostName();</span><br><span class="line">System.out.println(name);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">ip</span> <span class="operator">=</span> address.getHostAddress();</span><br><span class="line">System.out.println(ip);</span><br></pre></td></tr></table></figure><h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><h2 id="获取class对象的三种方式"><a href="#获取class对象的三种方式" class="headerlink" title="获取class对象的三种方式"></a>获取class对象的三种方式</h2><ol><li>Class.forName(“全类名”);  主要用在源代码阶段， 最常用</li><li>类名.class   主要用在加载阶段</li><li>对象.getClass( )    主要用在运行阶段</li></ol><p><img src="C:\Users\wilbur\AppData\Roaming\Typora\typora-user-images\image-20240804153636476.png" alt="image-20240804153636476"></p><h2 id="利用反射获取构造方法"><a href="#利用反射获取构造方法" class="headerlink" title="利用反射获取构造方法"></a>利用反射获取构造方法</h2><p><img src="C:\Users\wilbur\AppData\Roaming\Typora\typora-user-images\image-20240804155738958.png" alt="image-20240804155738958" style="zoom: 50%;" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//1.获取字节码文件对象</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.itheima.myreflect2.Student&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取构造方法</span></span><br><span class="line">Constructor[] cons1 = clazz.getConstructors();</span><br><span class="line"><span class="keyword">for</span>(Constructor con : cons1)&#123;</span><br><span class="line">System.out.println(con);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Constructor[] cons2 = clazz.getDeclaredConstructors();</span><br><span class="line"><span class="keyword">for</span>(Constructor con : cons2)&#123;</span><br><span class="line">System.out.println(con);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Constructor</span> <span class="variable">con3</span> <span class="operator">=</span> clazz.getConstructor();  <span class="comment">//不传递参数，返回的就是空参构造</span></span><br><span class="line">System.out.println(con3);</span><br><span class="line"></span><br><span class="line"><span class="comment">//传入相应构造方法中参数的字节码，返回相应的构造方法</span></span><br><span class="line"><span class="type">Constructor</span> <span class="variable">con4</span> <span class="operator">=</span> clazz.getDeclaredConstructor(String.class, <span class="type">int</span>.class)  </span><br><span class="line">System.out.println(con4);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取构造方法中的参数</span></span><br><span class="line">Parameter[] parameters = con4.getParameter();</span><br><span class="line"><span class="keyword">for</span>(Parameter parameter : parameters)&#123;</span><br><span class="line">    System.out.println(parameter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//利用构造方法创建对象</span></span><br><span class="line">con4.setAccessible(<span class="literal">true</span>); <span class="comment">//表示临时取消权限校验(con4为private构造方法，不取消会报错)</span></span><br><span class="line"><span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> (Student) con4.newInstance(<span class="string">&quot;张三&quot;</span>, <span class="number">23</span>);</span><br><span class="line">System.out.println(stu);</span><br></pre></td></tr></table></figure><h2 id="利用反射获取成员变量"><a href="#利用反射获取成员变量" class="headerlink" title="利用反射获取成员变量"></a>利用反射获取成员变量</h2><p><img src="C:\Users\wilbur\AppData\Roaming\Typora\typora-user-images\image-20240804155821835.png" alt="image-20240804155821835" style="zoom:50%;" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意：getFields()获取到的属性包括本类以及所有父类中声明为public的属性</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forNmae(<span class="string">&quot;con.itheima.myreflect3.Student&quot;</span>);</span><br><span class="line">Field[] fields = clazz.getFields();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(Field field : fields)&#123;</span><br><span class="line">System.out.println(field);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//....其他的方法与Constructor类似</span></span><br></pre></td></tr></table></figure><h2 id="利用反射获取成员方法"><a href="#利用反射获取成员方法" class="headerlink" title="利用反射获取成员方法"></a>利用反射获取成员方法</h2><p><img src="C:\Users\wilbur\AppData\Roaming\Typora\typora-user-images\image-20240804160823523.png" alt="image-20240804160823523" style="zoom:50%;" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.itheima.myreflect4.Student&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取单一的方法对象</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">m</span> <span class="operator">=</span> clazz.getDeclaredMethod(<span class="string">&quot;eat&quot;</span>, String.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取修饰符</span></span><br><span class="line"><span class="type">int</span> <span class="variable">modifiers</span> <span class="operator">=</span> m.getModifiers();</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取方法名</span></span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> m.getName();</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取方法的形参</span></span><br><span class="line">Parameter[] parameters = m.getParameters();</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取方法抛出的异常</span></span><br><span class="line">Class[] exceptionTypes = m.getExceptionTypes();</span><br><span class="line"></span><br><span class="line"><span class="comment">//运行方法</span></span><br><span class="line"><span class="comment">//Object invoke(Object obj, Object...args)</span></span><br><span class="line"><span class="comment">//参数一：用obj对象调用该方法  参数二：调用方法传递的实参</span></span><br><span class="line"><span class="comment">//返回值：有就用变量接受，没有就直接调用即可</span></span><br><span class="line"><span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">m.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> (String)m.invoke(s, <span class="string">&quot;热干面&quot;</span>);</span><br><span class="line">System.out.println(result);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="动态代理-听不懂"><a href="#动态代理-听不懂" class="headerlink" title="动态代理-听不懂"></a>动态代理-听不懂</h1><p>特点：五侵入式的给代码增加额外功能</p><p><img src="C:\Users\wilbur\AppData\Roaming\Typora\typora-user-images\image-20240804163710604.png" alt="image-20240804163710604" style="zoom:67%;" /></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;面向对象三大特性：封装，继承，多态&quot;&gt;&lt;a href=&quot;#面向对象三大特性：封装，继承，多态&quot; class=&quot;headerlink&quot; title=&quot;面向对象三大特性：封装，继承，多态&quot;&gt;&lt;/a&gt;面向对象三大特性：封装，继承，多态&lt;/h1&gt;&lt;h2 id=&quot;继承&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="编程Coding" scheme="https://github.wilbur-lz.cn/categories/%E7%BC%96%E7%A8%8BCoding/"/>
    
    
    <category term="JavaSE" scheme="https://github.wilbur-lz.cn/tags/JavaSE/"/>
    
  </entry>
  
  <entry>
    <title>Spring</title>
    <link href="https://github.wilbur-lz.cn/posts/6c92115f.html"/>
    <id>https://github.wilbur-lz.cn/posts/6c92115f.html</id>
    <published>2024-10-08T14:18:05.000Z</published>
    <updated>2024-10-11T08:49:34.756Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-容器：IoC"><a href="#1-容器：IoC" class="headerlink" title="1.容器：IoC"></a>1.容器：IoC</h1><ul><li>IoC 是 Inversion of Control 的简写，译为“控制反转”，它不是一门技术，而是一种设计思想。<br>IoC 的思想就是将原本在程序中手动创建对象的控制权，交由 Spring 框架来管理。</li><li>Spring 通过 IoC 容器来管理所有 Java 对象的实例化和初始化，控制对象与对象之间的依赖关系。我们将由 IoC 容器管理的 Java 对象称为 Spring Bean，它与使用关键字 new 创建的 Java 对象没有任何区别。</li><li>另外，Spring容器是使用的map集合进行存储bean对象</li></ul><h2 id="1-1-IoC容器"><a href="#1-1-IoC容器" class="headerlink" title="1.1 IoC容器"></a>1.1 IoC容器</h2><div class="note info no-icon flat"><p>控制反转,是指将对象的创建权力交给第三方容器管理,由容器负责对象的实例化，初始化，销毁等一些列操作。这种思想能够降低程序耦合度，提高程序扩展力。实现方式为DI：依赖注入。</p></div><p><strong>IoC容器在Spring的实现</strong></p><ol><li><strong>BeanFactory：</strong>这是 IoC 容器的基本实现，是 Spring 内部使用的接口。面向 Spring 本身，不提供给开发人员使用。</li><li><strong>ApplicationContext：</strong>BeanFactory 的<mark class="hl-label red">子接口</mark>，提供了更多高级特性。面向 Spring 的使用者，几乎所有场合都使用 ApplicationContext 而不是底层的 BeanFactory。</li><li><strong>ApplicationContext的主要实现类</strong></li></ol><div class="table-container"><table><thead><tr><th>类型名</th><th>简介</th></tr></thead><tbody><tr><td>ClassPathXmlApplicationContext</td><td>通过读取类路径下的 XML 格式的配置文件创建 IOC 容器对象</td></tr><tr><td>FileSystemXmlApplicationContext</td><td>通过文件系统路径读取 XML 格式的配置文件创建 IOC 容器对象</td></tr><tr><td>ConfigurableApplicationContext</td><td>ApplicationContext 的子接口，包含一些扩展方法 refresh() 和 close() ，让 ApplicationContext 具有启动、关闭和刷新上下文的能力。</td></tr><tr><td>WebApplicationContext</td><td>专门为 Web 应用准备，基于 Web 环境创建 IOC 容器对象，并将对象引入存入 ServletContext 域中。</td></tr></tbody></table></div><p><strong>IoC容器创建对象过程</strong><br><div class="note success no-icon flat"><ol><li>在xml文件中写入Bean的定义信息BeanDefinition</li><li>通过一个抽象(BeanDefinitionReader的实现类)将配置文件进行加载到IoC容器</li><li>IoC容器通过BeanFactory工厂+反射进行对象的实例化，初始化。并在代码中通过context.getBean(“类名首字母小写”)得到对象。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//利用反射获取对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    <span class="comment">// 获取类对象</span></span><br><span class="line">    <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;全类名&quot;</span>);</span><br><span class="line">    <span class="comment">// 调用Instance方法创建对象</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User)clazz.getDeclaredConstructor().newInstance();</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//利用xml文件创建对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//加载bean的配置文件</span></span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean的xml配置文件.xml&quot;</span>);</span><br><span class="line">    <span class="comment">//获取创建的对象</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User)context.getBean(<span class="string">&quot;类名首字母小写&quot;</span>);</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></div></p><h2 id="1-2-依赖注入DI"><a href="#1-2-依赖注入DI" class="headerlink" title="1.2 依赖注入DI"></a>1.2 依赖注入DI</h2><div class="note primary no-icon flat"><p><strong>依赖注入DI:</strong>是指Spring创建对象的过程中，将对象依赖属性通过配置进行注入。这个对象的属性可以是基本类型，当然，也可以是引用类型(比如其他类)。</p></div><p><strong>依赖注入的常见方式有两种:</strong></p><ul><li>set注入</li><li>构造器注入</li></ul><h2 id="1-3-基于XML管理Bean"><a href="#1-3-基于XML管理Bean" class="headerlink" title="1.3 基于XML管理Bean"></a>1.3 基于XML管理Bean</h2><div class="note info no-icon flat"><p>准备工作：创建一个User类，其中包含String类型的name属性和Integer类型的age属性,还有一个打印输出的run方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;System.out.println(<span class="string">&quot;run...&quot;</span>)&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><div class="note info no-icon flat"><p>其次，在xml文件中配置bean的信息</p></div><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;bean id=&quot;唯一id&quot; class=&quot;全类名&quot;&gt;&lt;/bean&gt; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;xxxx.User.xml&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></p></div><h3 id="1-3-1-获取bean"><a href="#1-3-1-获取bean" class="headerlink" title="1.3.1 获取bean"></a>1.3.1 获取bean</h3><h4 id="①方法一：根据id获取"><a href="#①方法一：根据id获取" class="headerlink" title="①方法一：根据id获取"></a><strong>①方法一：根据id获取</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//加载bean的配置文件</span></span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean.xml&quot;</span>);</span><br><span class="line">    <span class="comment">//获取创建的对象</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User)context.getBean(<span class="string">&quot;user&quot;</span>);  <span class="comment">//这里是根据bean的id来获取的对象(user为xml中bean的id)</span></span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="②方法二：根据类型获取"><a href="#②方法二：根据类型获取" class="headerlink" title="②方法二：根据类型获取"></a><strong>②方法二：根据类型获取</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//加载bean的配置文件</span></span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean.xml&quot;</span>);</span><br><span class="line">    <span class="comment">//获取创建的对象</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User)context.getBean(User.class);  <span class="comment">//这里是根据bean的类型获取的对象</span></span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note warning no-icon flat"><p>需要注意的是：当根据类型获取bean时，要求IOC容器中指定类型的bean有且只能有一个<br>当IOC容器中配置了两个同一类型的bean时，根据类型获取时会抛出异常：<strong>NoUniqueBeanDefinitionException: No qualifying bean of type</strong><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;xxx.User&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;xxx.User&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></p></div><h4 id="③方法三：根据类型和id获取"><a href="#③方法三：根据类型和id获取" class="headerlink" title="③方法三：根据类型和id获取"></a><strong>③方法三：根据类型和id获取</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//加载bean的配置文件</span></span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean.xml&quot;</span>);</span><br><span class="line">    <span class="comment">//获取创建的对象</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User)context.getBean(<span class="string">&quot;user&quot;</span>,User.class);  <span class="comment">//这里是根据bean的id和类型获取的对象</span></span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note info no-icon flat"><p>如果组件类实现了接口，此时</p><blockquote><p>如果该接口的实现类唯一，则可以通过接口类型来获取bean。<br>注意，xml文件中class的全类名还应该是实现类的全类名,只是在getBean中传入接口的class对象</p><p>如果该接口有多个实现类，则无法通过接口类型来获取bean</p></blockquote></div><h3 id="1-3-2-依赖注入-set注入"><a href="#1-3-2-依赖注入-set注入" class="headerlink" title="1.3.2 依赖注入-set注入"></a>1.3.2 依赖注入-set注入</h3><p><strong>步骤:</strong></p><ol><li>创建类，定义属性，以及属性的set方法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">book</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String author;</span><br><span class="line">    <span class="comment">//...还可以有其他类型的属性，比如数组，自定义类等...</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span>&#123;<span class="built_in">this</span>.name = name;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAuthor</span><span class="params">(String author)</span>&#123;<span class="built_in">this</span>.author = author;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>在Spring的xml配置文件中配置<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;book&quot;</span> <span class="attr">class</span>=<span class="string">&quot;xxx.book&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span> <span class="comment">&lt;!-- property属性会调用name对应的set方法 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;author&quot;</span> <span class="attr">value</span>=<span class="string">&quot;整点薯条&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="1-3-2-依赖注入-构造器注入"><a href="#1-3-2-依赖注入-构造器注入" class="headerlink" title="1.3.2 依赖注入-构造器注入"></a>1.3.2 依赖注入-构造器注入</h3><p><strong>步骤：</strong></p><ol><li>创建类，定义属性，生成有参数的构造方法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">book</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String author;</span><br><span class="line">    <span class="comment">//...还可以有其他类型的属性，比如数组，自定义类等...</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">book</span><span class="params">(String name, String author)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.author = author;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>在Spring的xml配置文件中配置<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 构造器注入 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;book&quot;</span> <span class="attr">class</span>=<span class="string">&quot;xxx.book&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;author&quot;</span> <span class="attr">value</span>=<span class="string">&quot;整点薯条&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="1-3-3-特殊值的注入"><a href="#1-3-3-特殊值的注入" class="headerlink" title="1.3.3 特殊值的注入"></a>1.3.3 特殊值的注入</h3><h4 id="①字面量赋值："><a href="#①字面量赋值：" class="headerlink" title="①字面量赋值："></a><strong>①字面量赋值：</strong></h4><blockquote><p>使用value属性给bean的属性赋值时，Spring会把value属性的值看做字面量<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;张三&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></p><h4 id="②NULL值："><a href="#②NULL值：" class="headerlink" title="②NULL值："></a><strong>②NULL值：</strong></h4><div class="note danger np-icon flat"><p>注意，注入null值并不是将value设置为null, 直接使用value=”null”，这里的null只是一个字面量而非空值</p></div><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 正确的赋值方法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">null</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="③xml实体："><a href="#③xml实体：" class="headerlink" title="③xml实体："></a><strong>③xml实体：</strong></h4><blockquote><p>xml实体是指在xml文件中有特定含义的字符, 比如&lt;,&gt;等…此时需要转义字符串代替<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 小于号在XML文档中用来定义标签的开始，不能随便使用 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 解决方案一：使用XML实体来代替 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;expression&quot;</span> <span class="attr">value</span>=<span class="string">&quot;a <span class="symbol">&amp;lt;</span> b&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;expression&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 解决方案二：使用CDATA节 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- CDATA中的C代表Character，是文本、字符的含义，CDATA就表示纯文本数据 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- XML解析器看到CDATA节就知道这里是纯文本，就不会当作XML标签或属性来解析 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 所以CDATA节中写什么符号都随意 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>&lt;![CDATA[a &lt; b]]&gt;<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure></p></blockquote><h3 id="1-3-4-为对象类型属性赋值"><a href="#1-3-4-为对象类型属性赋值" class="headerlink" title="1.3.4 为对象类型属性赋值"></a>1.3.4 为对象类型属性赋值</h3><div class="note info no-icon flat"><blockquote><p>部门类Dept<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dept</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String dname;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">info</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;部门名称：&quot;</span>+dname);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>员工类Emp<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Emp</span>&#123;</span><br><span class="line">    <span class="comment">//表示员工归属的部门</span></span><br><span class="line">    <span class="keyword">private</span> Dept dept;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; work...&quot;</span> + age);</span><br><span class="line">        dept.info();    <span class="comment">//调用对象属性的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote></div><h4 id="①引用外部bean："><a href="#①引用外部bean：" class="headerlink" title="①引用外部bean："></a><strong>①引用外部bean：</strong></h4><div class="note success no-icon flat"><blockquote><p>先在两个类中生成对应的set方法</p><ol><li>创建两个类对象：dept和emp</li><li>在emp的bean标签内，通过property(set注入方式)引入dept的bean<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">class</span>=<span class="string">&quot;xxx.Dept&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dname&quot;</span> <span class="attr">value</span>=<span class="string">&quot;财务部&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;emp&quot;</span> <span class="attr">class</span>=<span class="string">&quot;xxx.Emp&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;整点薯条&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;23&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 通过ref注入对象类型的属性 name中的dept为Emp类中setDept方法 ref中的dept表示引入的外部bean的id--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dept&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol></blockquote></div><h4 id="②内部bean："><a href="#②内部bean：" class="headerlink" title="②内部bean："></a><strong>②内部bean：</strong></h4><div class="note success no-icon flat"><p>直接在emp的bean标签内部定义要注入的bean</p></div><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;emp&quot;</span> <span class="attr">class</span>=<span class="string">&quot;xxx.Emp&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;整点薯条&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;23&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dept&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">class</span>=<span class="string">&quot;xxx.Dept&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dname&quot;</span> <span class="attr">value</span>=<span class="string">&quot;财务部&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="③级联属性赋值："><a href="#③级联属性赋值：" class="headerlink" title="③级联属性赋值："></a><strong>③级联属性赋值：</strong></h4><div class="note success no-icon flat"><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">class</span>=<span class="string">&quot;xxx.Dept&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dname&quot;</span> <span class="attr">value</span>=<span class="string">&quot;财务部&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;emp&quot;</span> <span class="attr">class</span>=<span class="string">&quot;xxx.Emp&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;整点薯条&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;23&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dept&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span>  <span class="comment">&lt;!-- 先引入外部bean --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dept.dname&quot;</span> <span class="attr">value</span>=<span class="string">&quot;研发部&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span> <span class="comment">&lt;!-- emp中dept对象属性的dname属性被覆盖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></div><h3 id="1-3-5-为数组类型属性赋值"><a href="#1-3-5-为数组类型属性赋值" class="headerlink" title="1.3.5 为数组类型属性赋值"></a>1.3.5 为数组类型属性赋值</h3><div class="note info no-icon flat"><blockquote><p>在员工类Emp中加入数组属性 String[] loves; 同时生成其对应的set方法</p></blockquote></div><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;emp&quot;</span> <span class="attr">class</span>=<span class="string">&quot;xxx.Emp&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;整点薯条&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;23&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dept&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span>  <span class="comment">&lt;!-- 先引入外部bean --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;loves&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>杀戮尖塔<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>学习<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>听歌<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">peoperty</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="1-3-6-为集合类型属性赋值"><a href="#1-3-6-为集合类型属性赋值" class="headerlink" title="1.3.6 为集合类型属性赋值"></a>1.3.6 为集合类型属性赋值</h3><h4 id="①为List集合类型属性赋值："><a href="#①为List集合类型属性赋值：" class="headerlink" title="①为List集合类型属性赋值："></a><strong>①为List集合类型属性赋值：</strong></h4><div class="note success no-icon flat"><blockquote><p>在Dept类中新增私有List<Emp>属性<mark class="hl-label green">empList</mark>，并生成其对应的set方法</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在dept的bean标签中，通过list和ref标签引入外部bean --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;emp1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;xxx.Emp&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;员工1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;20&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;emp2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;xxx.Emp&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;员工2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;30&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">class</span>=<span class="string">&quot;xxx.Dept&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;empList&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;emp1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ref</span>&gt;</span>  <span class="comment">&lt;!-- 通过ref标签向list中增加值 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;emp2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ref</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></div><h4 id="②为Map集合类型属性赋值："><a href="#②为Map集合类型属性赋值：" class="headerlink" title="②为Map集合类型属性赋值："></a><strong>②为Map集合类型属性赋值：</strong></h4><div class="note success no-icon flat"><blockquote><p>新增两个类，学生类Student和老师类Teacher,在Student类中新增Map属性Map<String, Teacher> teacherMap表示一名学生有多个任课老师</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在Student的bean标签中，通过map,entry,key,value,ref标签引入外部bean --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;teacher1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;xxx.Teacher&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;孔松霖&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sid&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;teacher2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;xxx.Teacher&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;失心悦&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sid&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;student&quot;</span> <span class="attr">class</span>=<span class="string">&quot;xxx.Student&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;teacherMap&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span>&gt;</span>          <span class="comment">&lt;!--map有一点复杂，在entry标签内还有key和value标签 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">key</span>&gt;</span>        <span class="comment">&lt;!-- key的值还需要通过value标签来注入 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">value</span>&gt;</span>化学老师<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">key</span>&gt;</span>       <span class="comment">&lt;!-- value的值如果是普通类型，直接使用value标签注入即可 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;teacher1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ref</span>&gt;</span> <span class="comment">&lt;!-- 如果是其他自定义类，则需要通过ref标签注入 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">key</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">value</span>&gt;</span>生物老师<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;teacher2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ref</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></div><h4 id="③引用集合类型的bean："><a href="#③引用集合类型的bean：" class="headerlink" title="③引用集合类型的bean："></a><strong>③引用集合类型的bean：</strong></h4><div class="note danger no-icon flat"><p>通过util:list/map/set…/ 标签引入，详细的方法参考尚硅谷Spring6教程。</p></div><h3 id="1-3-7-引入外部属性文件"><a href="#1-3-7-引入外部属性文件" class="headerlink" title="1.3.7 引入外部属性文件"></a>1.3.7 引入外部属性文件</h3><blockquote><p>使用场景：当很多bean在同一个xml文件中配置和属性的注入时，修改和维护起来很麻烦。所以我们会把一些特定的值放到外部文件中，然后引入外部文件，进行注入。这样，需要修改值时直接到外部文件中修改相应的值即可。最经典的就是数据库的配置。</p></blockquote><p><strong>步骤:</strong></p><h4 id="①在jdbc-xml引入数据库相关的依赖："><a href="#①在jdbc-xml引入数据库相关的依赖：" class="headerlink" title="①在jdbc.xml引入数据库相关的依赖："></a><strong>①在jdbc.xml引入数据库相关的依赖：</strong></h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">&lt;!-- MySQL驱动 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.30<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 数据源 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.15<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="②创建外部属性文件："><a href="#②创建外部属性文件：" class="headerlink" title="②创建外部属性文件："></a><strong>②创建外部属性文件：</strong></h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">jdbc.user</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">jdbc.password</span>=<span class="string">atguigu</span></span><br><span class="line"><span class="attr">jdbc.url</span>=<span class="string">jdbc:mysql://localhost:3306/ssm?serverTimezone=UTC</span></span><br><span class="line"><span class="attr">jdbc.driver</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br></pre></td></tr></table></figure><h4 id="③在Spring配置文件中引入外部文件："><a href="#③在Spring配置文件中引入外部文件：" class="headerlink" title="③在Spring配置文件中引入外部文件："></a><strong>③在Spring配置文件中引入外部文件：</strong></h4><p>先在配置文件顶部引入context(自定义?)命名空间<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 引入外部属性文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:jdbc.properties&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context:property-placeholder</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 完成配置信息的注入 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;druidDataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.user&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="1-3-8-bean的作用域"><a href="#1-3-8-bean的作用域" class="headerlink" title="1.3.8 bean的作用域"></a>1.3.8 bean的作用域</h3><p><strong>①概念</strong><br><div class="note success no-icon flat"><p>在Spring中可以通过配置bean标签的scope属性来指定bean的作用域范围，各取值含义参加下表：</p><div class="table-container"><table><thead><tr><th>取值</th><th>含义</th><th>创建对象的时机</th></tr></thead><tbody><tr><td>singleton（默认）</td><td>在IOC容器中，这个bean的对象始终为单实例</td><td>IOC容器初始化时</td></tr><tr><td>prototype</td><td>这个bean在IOC容器中有多个实例</td><td>获取bean时</td></tr></tbody></table></div><p>如果是在WebApplicationContext环境下还会有另外几个作用域（但不常用）：</p><div class="table-container"><table><thead><tr><th>取值</th><th>含义</th></tr></thead><tbody><tr><td>request</td><td>在一个请求范围内有效</td></tr><tr><td>session</td><td>在一个会话范围内有效</td></tr></tbody></table></div></div><br><strong>详细可看这个视频</strong><br><a class="tag-Link" target="_blank" href="https://www.bilibili.com/video/BV1kR4y1b7Qc?p=32&spm_id_from=pageDriver&vd_source=eb0f3f74a814cc08c9f323d51f922175">    <div class="tag-link-tips">引用站外地址</div>    <div class="tag-link-bottom">        <div class="tag-link-left" style="background-image: url(https://api.iowen.cn/favicon/www.bilibili.com/video/BV1kR4y1b7Qc?p=32&spm_id_from=pageDriver&vd_source=eb0f3f74a814cc08c9f323d51f922175.png);"></div>        <div class="tag-link-right">            <div class="tag-link-title">bean的作用域</div>            <div class="tag-link-sitename">bilibili</div>        </div>        <i class="fa-solid fa-angle-right"></i>    </div>    </a></p><h3 id="1-3-8-bean的生命周期"><a href="#1-3-8-bean的生命周期" class="headerlink" title="1.3.8 bean的生命周期"></a>1.3.8 bean的生命周期</h3><p><strong>①具体的生命周期过程</strong><br><div class="note info on-icon flat"><ul><li><p>bean对象创建（调用无参构造器）</p></li><li><p>给bean对象设置属性</p></li><li><p>bean的后置处理器（初始化之前）</p></li><li><p>bean对象初始化（需在配置bean时指定初始化方法）</p></li><li><p>bean的后置处理器（初始化之后）</p></li><li><p>bean对象就绪可以使用</p></li><li><p>bean对象销毁（需在配置bean时指定销毁方法）</p></li><li><p>IOC容器关闭</p></li></ul><blockquote><p><mark class="hl-label default">注意：orange</mark>Spring在bean为多例模式下ioc容器在实例化bean对象后不会跟踪bean的生命周期，而是把控制权交给其调用者</p></blockquote></div><br><strong>②创建User类</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;生命周期：1、创建对象&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;生命周期：2、依赖注入&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initMethod</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;生命周期：4、初始化&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroyMethod</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;生命周期：6、销毁&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123; name=&quot;</span>+name+<span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>③配置bean</strong><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用init-method属性指定初始化方法 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 使用destroy-method属性指定销毁方法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;xxx.User&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;initMethod&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;destroyMethod&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;整点薯条&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><br><strong>④测试这几个方法</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="comment">//注意要用实现类ClassPathXmlApplicationContext，而不是接口ApplicationContext(接口中没有销毁方法)</span></span><br><span class="line">    <span class="type">ClassPathXmlApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;xxx.beanLife&quot;</span>);</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;user&quot;</span>, User.class);</span><br><span class="line">    System.put.println(<span class="string">&quot;生命周期：5、bean对象可以使用&quot;</span>+user);</span><br><span class="line">    context.close();   <span class="comment">//执行销毁方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>⑤后置处理器</strong><br><div class="note warning no-icon flat"><p>bean的后置处理器会在生命周期的初始化前后添加额外的操作，需要实现BeanPostProcessor接口，且配置到IOC容器中，需要注意的是，bean后置处理器不是单独针对某一个bean生效，而是针对IOC容器中所有bean都会执行</p></div><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//需要创建一个类MyProcessor并实现BeanPostProcessor接口，然后在xml文件中配置这个bean</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanPostProcessor</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span>  <span class="comment">//初始化前后置处理器执行的操作</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;☆☆☆&quot;</span> + beanName + <span class="string">&quot; = &quot;</span> + bean);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span>  <span class="comment">//初始化后 后置处理器执行的操作</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;★★★&quot;</span> + beanName + <span class="string">&quot; = &quot;</span> + bean);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在IOC容器中配置后置处理器：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- bean的后置处理器要放入IOC容器才能生效 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myProcessor&quot;</span> <span class="attr">class</span>=<span class="string">&quot;xxx.MyProcessor&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="1-3-8-基于xml自动装配"><a href="#1-3-8-基于xml自动装配" class="headerlink" title="1.3.8 基于xml自动装配"></a>1.3.8 基于xml自动装配</h3><blockquote><p>自动装配：<br>根据指定的策略，在IOC容器中匹配某一个bean，自动为指定的bean中所依赖的类类型或接口类型属性赋值</p><p>使用bean标签的autowire属性设置自动装配效果</p><p>自动装配方式：byType</p><p>byType：根据类型匹配IOC容器中的某个兼容类型的bean，为属性自动赋值</p><p>若在IOC中，没有任何一个兼容类型的bean能够为属性赋值，则该属性不装配，即值为默认值null</p><p>若在IOC中，有多个兼容类型的bean能够为属性赋值，则抛出异常NoUniqueBeanDefinitionException</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userController&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring6.autowire.controller.UserController&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byType&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring6.autowire.service.impl.UserServiceImpl&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byType&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring6.autowire.dao.impl.UserDaoImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>自动装配方式：byName</p><p>byName：将自动装配的属性的set方法后面的名称，作为bean的id在IOC容器中匹配相对应的bean进行赋值</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userController&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring6.autowire.controller.UserController&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byName&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring6.autowire.service.impl.UserServiceImpl&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byName&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userServiceImpl&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring6.autowire.service.impl.UserServiceImpl&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byName&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring6.autowire.dao.impl.UserDaoImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDaoImpl&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring6.autowire.dao.impl.UserDaoImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="1-4-基于注解管理bean"><a href="#1-4-基于注解管理bean" class="headerlink" title="1.4 基于注解管理bean"></a>1.4 基于注解管理bean</h2><blockquote><p>Spring通过注解实现自动装配的步骤如下：</p><ol><li>引入依赖</li><li>开启组件扫描</li><li>使用注解引入bean</li><li>依赖注入</li></ol><p>注解可以放在类，方法，以及成员变量上面</p></blockquote><div class="note success no-icon flat"><p>Spring 提供了以下多个注解，这些注解可以直接标注在 Java 类上，将它们定义成 Spring Bean。</p><div class="table-container"><table><thead><tr><th>注解</th><th>说明</th></tr></thead><tbody><tr><td>@Component</td><td>该注解用于描述 Spring 中的 Bean，它是一个泛化的概念，仅仅表示容器中的一个组件（Bean），并且可以作用在应用的任何层次，例如 Service 层、Dao 层等。  使用时只需将该注解标注在相应类上即可。</td></tr><tr><td>@Repository</td><td>该注解用于将数据访问层（Dao 层）的类标识为 Spring 中的 Bean，其功能与 @Component 相同。</td></tr><tr><td>@Service</td><td>该注解通常作用在业务层（Service 层），用于将业务层的类标识为 Spring 中的 Bean，其功能与 @Component 相同。</td></tr><tr><td>@Controller</td><td>该注解通常作用在控制层（如SpringMVC 的 Controller），用于将控制层的类标识为 Spring 中的 Bean，其功能与 @Component 相同。</td></tr></tbody></table></div></div><h3 id="1-4-1-Autowired注入"><a href="#1-4-1-Autowired注入" class="headerlink" title="1.4.1 @Autowired注入"></a>1.4.1 @Autowired注入</h3><div class="note info no-icon flat"><p>单独使用@Autowired注入，<mark class="hl-label red"><strong>默认根据类型自动装配</strong></mark><br>该注解可以使用在</p><ol><li>构造方法上</li><li>方法上</li><li>形参上</li><li>属性上</li><li>注解上</li></ol></div><div class="note warning no-icon flat"><p>注意：可以使用@Autowired和@Qualifier注解联合实现根据名称自动装配, 适用于有多个实现类的接口注入</p></div><h3 id="1-4-2-Resource注入"><a href="#1-4-2-Resource注入" class="headerlink" title="1.4.2 @Resource注入"></a>1.4.2 @Resource注入</h3><p><strong>@Autowired和@Resource 的区别</strong></p><ul><li>@Resource注解是JDK扩展包中的，也就是说属于JDK的一部分。所以该注解是标准注解，更加具有通用性。(JSR-250标准中制定的注解类型。JSR是Java规范提案。)</li><li>@Autowired注解是Spring框架自己的。<div class="note primary no-icon flat"><ul><li><strong>@Resource注解默认根据名称装配byName，未指定name时，使用属性名作为name。通过name找不到的话会自动启动通过类型byType装配。</strong></li><li><strong>@Autowired注解默认根据类型装配byType，如果想根据名称装配，需要配合@Qualifier注解一起用。</strong></li></ul></div></li><li>@Resource注解用在属性上、setter方法上。</li><li>@Autowired注解用在属性上、setter方法上、构造方法上、构造方法参数上。</li></ul><p>@Resource注解属于JDK扩展包，所以不在JDK当中，需要额外引入以下依赖：【<strong>如果是JDK8的话不需要额外引入依赖。高于JDK11或低于JDK8需要引入以下依赖。</strong>】</p><h3 id="1-4-3-Spring全注解开发"><a href="#1-4-3-Spring全注解开发" class="headerlink" title="1.4.3 Spring全注解开发"></a>1.4.3 Spring全注解开发</h3><blockquote><p>全注解开发就是利用配置类来代替原来的spring配置文件<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>                          <span class="comment">//表明这是一个Spring的配置类</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.atguigu.spring6&quot;)</span>  <span class="comment">// 需要扫描的包路径</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Spring6Config</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><h1 id="2-手写IoC-原理"><a href="#2-手写IoC-原理" class="headerlink" title="2. 手写IoC - 原理"></a>2. 手写IoC - 原理</h1><h2 id="2-1-Java反射"><a href="#2-1-Java反射" class="headerlink" title="2.1 Java反射"></a>2.1 Java反射</h2><blockquote><p><code>Java</code>反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为<code>Java</code>语言的反射机制。简单来说，反射机制指的是程序在运行时能够获取自身的信息。<br><div class="note primary no-icon flat"><ol><li>获取Class对象的几种方式<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 类名.class</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Car.class;</span><br><span class="line"><span class="comment">//2. 对象.getClass</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Car</span>().getClass();</span><br><span class="line"><span class="comment">//3. Class.forName(&quot;全类名&quot;)</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;xxxx.Car&quot;</span>);</span><br><span class="line"><span class="comment">//4. 实例化的方法, 有几种方法，详情见JavaSE-反射一章的内容</span></span><br><span class="line"><span class="type">Car</span> <span class="variable">car</span> <span class="operator">=</span> (Car)clazz.getDeclaredConstructor().newInstance();</span><br></pre></td></tr></table></figure></li><li>获取构造方法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先得到Class对象</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Car.class;</span><br><span class="line"><span class="comment">//1. 获取所有构造方法</span></span><br><span class="line">Constructor[] constructors = clazz.getConstructors();  <span class="comment">//获取类中所有的public构造方法</span></span><br><span class="line">Constructor[] constructors = clazz.getDeclaredConstructors();  <span class="comment">//获取类中所有的构造方法</span></span><br><span class="line"><span class="comment">//2. 利用有参构造创建对象</span></span><br><span class="line"><span class="type">Constructor</span> <span class="variable">c1</span> <span class="operator">=</span> clazz.getConstructor(String.class, <span class="type">int</span>.class, String.class);</span><br><span class="line"><span class="type">Car</span> <span class="variable">car1</span> <span class="operator">=</span> (Car)c1.newInstance(<span class="string">&quot;法拉利&quot;</span>, <span class="number">10</span>, <span class="string">&quot;红色&quot;</span>);   <span class="comment">//构造public构造方法</span></span><br><span class="line"></span><br><span class="line"><span class="type">Constructor</span> <span class="variable">c2</span> <span class="operator">=</span> clazz.getConstructor(String.class, <span class="type">int</span>.class, String.class);</span><br><span class="line">c2.setAccessible(<span class="literal">true</span>);   <span class="comment">//设置private可以访问</span></span><br><span class="line"><span class="type">Car</span> <span class="variable">car2</span> <span class="operator">=</span> (Car)c2.newInstance(<span class="string">&quot;小米suv7&quot;</span>, <span class="number">5</span>, <span class="string">&quot;青色&quot;</span>);   <span class="comment">//构造private构造方法</span></span><br></pre></td></tr></table></figure></li><li>获取属性<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Car.class;  <span class="comment">//先得到class对象</span></span><br><span class="line"><span class="comment">//获取所有public属性</span></span><br><span class="line">Field[] fields = clazz.getFields();</span><br><span class="line"><span class="comment">//获取所有属性，包含private</span></span><br><span class="line">Field[] fields = clazz.getDeclaredFields();</span><br></pre></td></tr></table></figure></li><li>获取方法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Car</span> <span class="variable">car</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Car</span>(<span class="string">&quot;奔驰&quot;</span>, <span class="number">10</span>, <span class="string">&quot;黑色&quot;</span>);</span><br><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> car.getClass();</span><br><span class="line"><span class="comment">//1. 获取所有public方法，包括父类中的public方法</span></span><br><span class="line">Method[] methods = clazz.getMethods();</span><br><span class="line"><span class="keyword">for</span>(Method m: methods)&#123;</span><br><span class="line">    <span class="keyword">if</span>(m.getName().equals(<span class="string">&quot;toString&quot;</span>))&#123;  <span class="comment">//调用方法</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">invoke</span> <span class="operator">=</span> (String)m.invoke(car, Object...args);  <span class="comment">//参数1：对象  参数2: 被调用方法形参的值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2. private方法，当然，如果要调用私有方法,还需要设置private可以被访问</span></span><br><span class="line">Method[] methods = clazz.getDeclaredMethods();  <span class="comment">//只能获取到当前运行的类中的所有方法,不包含父类的方法</span></span><br></pre></td></tr></table></figure></li></ol></div></p></blockquote><h2 id="2-2-⭐⭐⭐IoC实现"><a href="#2-2-⭐⭐⭐IoC实现" class="headerlink" title="2.2 ⭐⭐⭐IoC实现"></a>2.2 ⭐⭐⭐IoC实现</h2><div class="note info no-icon flat"><p><strong>步骤</strong></p><ol><li>创建子模块springIoc</li><li>创建测试类<code>service</code> <code>dao</code></li><li>创建两个注解: <code>@Bean</code>创建对象, <code>@Di</code>属性注入</li><li>创建bean容器接口ApplicationContext，定义方法返回bean对象</li><li>实现bean容器接口: 返回对象，根据包规则加载bean(扫描包和其下面的所有子包，看类上是否有@Bean注解，如果有则将这个类通过反射进行实例化)</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ApplicationContext的实现类AnnotationApplicationContext的构造方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">AnnotationApplicationContext</span><span class="params">(String basePackage)</span>&#123;</span><br><span class="line">        <span class="comment">//1. 把.替换为\</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">packagePath</span> <span class="operator">=</span> basePackage.replaceAll(<span class="string">&quot;\\.&quot;</span>, <span class="string">&quot;\\\\&quot;</span>);</span><br><span class="line">        <span class="comment">//2. 获取包的绝对路径</span></span><br><span class="line">        <span class="keyword">try</span> &#123; <span class="comment">//TODO 这几个url的方法作用不是很懂，好像是获取target目录下的.class文件路径</span></span><br><span class="line">            Enumeration&lt;URL&gt; urls = Thread.currentThread().getContextClassLoader().getResources(packagePath);</span><br><span class="line">            <span class="keyword">while</span> (urls.hasMoreElements())&#123;</span><br><span class="line">                <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> urls.nextElement();</span><br><span class="line">                <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> URLDecoder.decode(url.getFile(), <span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">                <span class="comment">//获取包前面的路径</span></span><br><span class="line">                rootPath = filePath.substring(<span class="number">0</span>, filePath.length()-packagePath.length());</span><br><span class="line">                <span class="comment">//包扫描</span></span><br><span class="line">                loadBean(<span class="keyword">new</span> <span class="title class_">File</span>(filePath));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//属性注入</span></span><br><span class="line">        loadDi();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div><div class="note success no-icon flat"><p><mark class="hl-label red"><strong>⭐⭐⭐扫描包并将包中带有@Bean注解的类加载到beanFactory的map集合中</strong></mark><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 扫描包，把包中的类加载到beanFactory中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> file</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">loadBean</span><span class="params">(File file)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//1. 判断是否是文件夹</span></span><br><span class="line">        <span class="keyword">if</span>(file.isDirectory())&#123;</span><br><span class="line">            <span class="comment">//2. 获取文件夹里面的所有内容</span></span><br><span class="line">            File[] childrenFiles = file.listFiles();</span><br><span class="line">            <span class="comment">//3. 判断文件夹里为空，直接返回</span></span><br><span class="line">            <span class="keyword">if</span>(childrenFiles == <span class="literal">null</span> || childrenFiles.length == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//4. 否则，遍历</span></span><br><span class="line">            <span class="keyword">for</span> (File childFile : childrenFiles) &#123;</span><br><span class="line">                <span class="comment">//4.1 如果还是文件夹，递归</span></span><br><span class="line">                <span class="keyword">if</span>(childFile.isDirectory()) loadBean(childFile);</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//4.2 如果是文件，得到包路径+类名称部分</span></span><br><span class="line">                    <span class="type">String</span> <span class="variable">pathWithClass</span> <span class="operator">=</span> childFile.getAbsolutePath().substring(rootPath.length() - <span class="number">1</span>);</span><br><span class="line">                    <span class="comment">//4.3 如果文件是 .class文件，则加载类，否则，直接返回</span></span><br><span class="line">                    <span class="keyword">if</span>(pathWithClass.endsWith(<span class="string">&quot;.class&quot;</span>))&#123;</span><br><span class="line">                        <span class="comment">//4.4 把路径中的\替换为. 把.class去掉</span></span><br><span class="line">                        <span class="type">String</span> <span class="variable">fullName</span> <span class="operator">=</span> pathWithClass.replaceAll(<span class="string">&quot;\\\\&quot;</span>, <span class="string">&quot;.&quot;</span>).replace(<span class="string">&quot;.class&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">                        <span class="comment">//4.5 判断类上面是否有@Bean注解</span></span><br><span class="line">                        Class&lt;?&gt; clazz = Class.forName(fullName);</span><br><span class="line">                        <span class="keyword">if</span>(!clazz.isInterface())&#123;</span><br><span class="line">                            <span class="type">Bean</span> <span class="variable">annotation</span> <span class="operator">=</span> clazz.getAnnotation(Bean.class);</span><br><span class="line">                            <span class="keyword">if</span>(annotation != <span class="literal">null</span>)&#123;</span><br><span class="line">                                <span class="comment">//4.6 如果有，则创建对象，放入beanFactory中</span></span><br><span class="line">                                <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> clazz.getConstructor().newInstance();</span><br><span class="line">                                <span class="keyword">if</span>(clazz.getInterfaces().length&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                                    beanFactory.put(clazz.getInterfaces()[<span class="number">0</span>], instance);</span><br><span class="line">                                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                                    beanFactory.put(clazz, instance);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p></div><div class="note primary no-icon flat"><p><mark class="hl-label red"><strong>⭐⭐⭐属性注入</strong></mark><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 属性注入</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">loadDi</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 实例化的对象都在beanFactory中</span></span><br><span class="line">        <span class="comment">//1. 遍历beanFactory的map集合</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Class, Object&gt; entry : beanFactory.entrySet()) &#123;</span><br><span class="line">            <span class="comment">//2. 得到bean对象</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">            <span class="comment">//3. 得到bean对象的所有属性</span></span><br><span class="line">            Field[] fields = bean.getClass().getDeclaredFields();</span><br><span class="line">            <span class="comment">//4. 遍历属性</span></span><br><span class="line">            <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">                <span class="comment">//5. 判断属性上面是否有@Di注解</span></span><br><span class="line">                <span class="type">Di</span> <span class="variable">annotation</span> <span class="operator">=</span> field.getAnnotation(Di.class);</span><br><span class="line">                <span class="keyword">if</span> (annotation != <span class="literal">null</span>)&#123;</span><br><span class="line">                    <span class="comment">//注入属性值</span></span><br><span class="line">                    field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        field.set(bean, beanFactory.get(field.getType()));</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p></div><h1 id="3-⭐⭐⭐面向切面-AOP"><a href="#3-⭐⭐⭐面向切面-AOP" class="headerlink" title="3. ⭐⭐⭐面向切面: AOP"></a>3. ⭐⭐⭐面向切面: AOP</h1><h2 id="3-1-代理模式"><a href="#3-1-代理模式" class="headerlink" title="3.1 代理模式"></a>3.1 代理模式</h2><blockquote><p>二十三种设计模式中的一种，属于结构型模式。它的作用就是通过提供一个代理类，让我们在调用目标方法的时候，不再是直接对目标方法进行调用，而是通过代理类<strong>间接</strong>调用。让不属于目标方法核心逻辑的代码从目标方法中剥离出来——<strong>解耦</strong>。调用目标方法时先调用代理对象的方法，减少对目标方法的调用和打扰，同时让附加功能能够集中在一起也有利于统一维护。</p></blockquote><ul><li>代理：将非核心逻辑(比如日志功能…)剥离出来以后，封装这些非核心逻辑的类、对象、方法。</li><li>目标：被代理“套用”了非核心逻辑代码的类、对象、方法。</li></ul><h2 id="3-2-静态代理"><a href="#3-2-静态代理" class="headerlink" title="3.2 静态代理"></a>3.2 静态代理</h2><blockquote><p>静态代理确实实现了解耦，但是由于代码都写死了，完全不具备任何的灵活性。就拿日志功能来说，将来其他地方也需要附加日志，那还得再声明更多个静态代理类，那就产生了大量重复的代码，日志功能还是分散的，没有统一管理。不实用。</p></blockquote><h2 id="3-3-动态代理"><a href="#3-3-动态代理" class="headerlink" title="3.3 动态代理"></a>3.3 动态代理</h2><p>生产代理对象的工厂类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ProxyFactory</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getProxy</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * newProxyInstance()：创建一个代理实例</span></span><br><span class="line"><span class="comment">         * 其中有三个参数：</span></span><br><span class="line"><span class="comment">         * 1、classLoader：加载动态生成的代理类的类加载器</span></span><br><span class="line"><span class="comment">         * 2、interfaces：目标对象实现的所有接口的class对象所组成的数组</span></span><br><span class="line"><span class="comment">         * 3、invocationHandler：设置代理对象实现目标对象方法的过程，即代理类中如何重写接口中的抽象方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> target.getClass().getClassLoader();</span><br><span class="line">        Class&lt;?&gt;[] interfaces = target.getClass().getInterfaces();</span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">invocationHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * proxy：代理对象</span></span><br><span class="line"><span class="comment">                 * method：代理对象需要实现的方法，即其中需要重写的方法</span></span><br><span class="line"><span class="comment">                 * args：method所对应方法的参数</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;[动态代理][日志] &quot;</span>+method.getName()+<span class="string">&quot;，参数：&quot;</span>+ Arrays.toString(args));</span><br><span class="line">                    result = method.invoke(target, args);</span><br><span class="line">                    System.out.println(<span class="string">&quot;[动态代理][日志] &quot;</span>+method.getName()+<span class="string">&quot;，结果：&quot;</span>+ result);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    System.out.println(<span class="string">&quot;[动态代理][日志] &quot;</span>+method.getName()+<span class="string">&quot;，异常：&quot;</span>+e.getMessage());</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;[动态代理][日志] &quot;</span>+method.getName()+<span class="string">&quot;，方法执行完毕&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(classLoader, interfaces, invocationHandler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-4-⭐⭐⭐AOP面向切面编程"><a href="#3-4-⭐⭐⭐AOP面向切面编程" class="headerlink" title="3.4 ⭐⭐⭐AOP面向切面编程"></a>3.4 ⭐⭐⭐AOP面向切面编程</h2><blockquote><p>AOP（Aspect Oriented Programming）是一种设计思想，是软件设计领域中的面向切面编程，它是面向对象编程的一种补充和完善，<mark class="hl-label default">它以通过预编译方式和运行期动态代理方式实现，在不修改源代码的情况下，给程序动态统一添加额外功能的一种技术。green</mark>利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。</p></blockquote><p><strong>相关术语</strong></p><ul><li>通知(增强)Advice<blockquote><p><strong>增强，通俗说，就是你想要增强的功能，比如 安全，事务，日志等。</strong><br>每一个横切关注点上要做的事情都需要写一个方法来实现，这样的方法就叫通知方法。</p><div class="note info no-icon flat"><ul><li>前置通知：在被代理的目标方法<strong>前</strong>执行</li><li>返回通知：在被代理的目标方法<strong>成功结束</strong>后执行</li><li>异常通知：在被代理的目标方法<strong>异常结束</strong>后执行</li><li>后置通知：在被代理的目标方法<strong>最终结束</strong>后执行</li><li>环绕通知：使用try…catch…finally结构围绕<strong>整个</strong>被代理的目标方法，包括上面四种通知对应的所有位置<blockquote><p><mark class="hl-label red">后置通知和返回通知的区别:</mark> 后置通知:不管方法是否有异常，都会执行该通知；而返回通知是方法正常结束时才会执行。</p></blockquote></li></ul></div></blockquote></li><li>切面Aspect<blockquote><p>封装通知方法的类。</p></blockquote></li><li>连接点JoinPoint<blockquote><p>通俗说，就是spring允许你使用通知的地方</p></blockquote></li><li>切入点Pointcut<blockquote><p><strong>Spring 的 AOP 技术可以通过切入点定位到特定的连接点。通俗说，要实际去增强的方法</strong><br>切点通过 org.springframework.aop.Pointcut 接口进行描述，它使用类和方法作为连接点的查询条件。</p><div class="note success no-icon flat"><p>简单来讲，就是在在Advice的时间、在Pointcut的位置，执行Aspect。</p></div></blockquote></li></ul><h3 id="3-4-1-基于注解的AOP"><a href="#3-4-1-基于注解的AOP" class="headerlink" title="3.4.1 基于注解的AOP"></a>3.4.1 基于注解的AOP</h3><p><strong>步骤</strong></p><ol><li>引入aop相关依赖</li><li>创建目标资源 — 接口类和实现类<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.springaop.annoaop;</span><br><span class="line"><span class="comment">//接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">sub</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">mul</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">div</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现类</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CalculatorImpl</span> <span class="keyword">implements</span> <span class="title class_">Calculator</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;<span class="keyword">return</span> i+j;&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sub</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;<span class="keyword">return</span> i-j;&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">mul</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;<span class="keyword">return</span> i*j;&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">div</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;<span class="keyword">return</span> i/j;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>创建切面类 — 切入点和通知类型<div class="note info no-icon flat"><p>切入点表达式：<code>value=&quot;execution(权限修饰符 方法返回值 com.xxx.*.*(..))&quot;</code></p><blockquote><p>第一个.<em>表示这个包下的所有类/接口;第二个.</em>表示这些类/接口中的所有方法都会被增强;(..)表示这些方法中的参数,..表示任意参数;</p></blockquote></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span> <span class="comment">//交给Spring IOC容器管理</span></span><br><span class="line"><span class="meta">@Aspect</span>    <span class="comment">//表明这是一个切面类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogAspect</span>&#123;</span><br><span class="line">    <span class="comment">//设置切入点和通知类型</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 切入点：通过切入点表达式设置</span></span><br><span class="line"><span class="comment">     * 通知类型:</span></span><br><span class="line"><span class="comment">     * 1. 前置通知<span class="doctag">@Before</span></span></span><br><span class="line"><span class="comment">     * 2. 返回通知<span class="doctag">@AfterReturning</span></span></span><br><span class="line"><span class="comment">     * 3. 异常通知<span class="doctag">@AfterThrowing</span></span></span><br><span class="line"><span class="comment">     * 4. 后置通知<span class="doctag">@After</span></span></span><br><span class="line"><span class="comment">     * 5. 环绕通知<span class="doctag">@Around</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//前置通知与后置通知类似，以前置通知为例</span></span><br><span class="line">    <span class="meta">@Before(value=&quot;execution(public int com.itheima.springaop.annoaop.CalculatorImpl.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">beforeMethod</span><span class="params">(JoinPoint joinPoint)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> joinPoint.getSignature().getName();</span><br><span class="line">        Object[] args = joinPoint.getArgs();</span><br><span class="line">        System.out.println(<span class="string">&quot;Logger--&gt;前置通知,方法名称:&quot;</span>+methodName+<span class="string">&quot;,参数:&quot;</span>+ Arrays.toString(args));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回通知, 注意returning</span></span><br><span class="line">    <span class="meta">@AfterReturning(value = &quot;execution(public int com.itheima.springaop.annoaop.CalculatorImpl.*(..))&quot;,returning = &quot;result&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterReturningMethod</span><span class="params">(JoinPoint joinPoint,Object result)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> joinPoint.getSignature().getName();</span><br><span class="line">        System.out.println(<span class="string">&quot;Logger--&gt;返回通知,方法名称:&quot;</span>+methodName+<span class="string">&quot;,结果:&quot;</span>+result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//异常通知，注意throwing</span></span><br><span class="line">    <span class="meta">@AfterThrowing(value = &quot;execution(public int com.itheima.springaop.annoaop.CalculatorImpl.*(..))&quot;,throwing = &quot;ex&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterThrowingMethod</span><span class="params">(JoinPoint joinPoint,Throwable ex)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> joinPoint.getSignature().getName();</span><br><span class="line">        System.out.println(<span class="string">&quot;Logger--&gt;异常通知,方法名称:&quot;</span>+methodName+<span class="string">&quot;,异常信息:&quot;</span>+ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//环绕通知 切入点是ProceedingJoinPoint类型</span></span><br><span class="line">    <span class="meta">@Around(value = &quot;execution(public int com.itheima.springaop.annoaop.CalculatorImpl.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">aroundMethod</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> joinPoint.getSignature().getName();</span><br><span class="line">        Object[] args = joinPoint.getArgs();</span><br><span class="line">        <span class="type">String</span> <span class="variable">argString</span> <span class="operator">=</span> Arrays.toString(args);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;环绕通知，目标方法执行前执行&quot;</span>);</span><br><span class="line">            <span class="comment">//调用目标方法</span></span><br><span class="line">            result = joinPoint.proceed();</span><br><span class="line">            System.out.println(<span class="string">&quot;环绕通知，目标方法返回值之后&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Throwable throwable)&#123;</span><br><span class="line">            throwable.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot;环绕通知，目标方法出现异常后执行&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;环绕通知，目标方法执行完毕&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note info no-icon flat"><ol><li><strong>重用切入点表达式：</strong><br>当多个通知的切入点一样时，可以在再随便定义一个方法pointCut，在这个方法上加上<code>@PointCut(value=&quot;切入点表达式&quot;)</code>, 然后在其他通知注解中直接通过<code>value=&quot;pointCut&quot;</code>引入切点表达式。</li><li><strong>切面优先级：</strong><br>相同目标方法上同时存在多个切面时，切面的优先级控制切面的<strong>内外嵌套</strong>顺序。</li></ol><ul><li>优先级高的切面：外面</li><li>优先级低的切面：里面</li></ul><p>使用@Order注解可以控制切面的优先级：</p><ul><li>@Order(较小的数)：优先级高</li><li>@Order(较大的数)：优先级低</li></ul></div></li></ol><h3 id="3-4-2-基于xml的AOP"><a href="#3-4-2-基于xml的AOP" class="headerlink" title="3.4.2 基于xml的AOP"></a>3.4.2 基于xml的AOP</h3><p><strong>了解即可</strong><br><a class="tag-Link" target="_blank" href="https://www.bilibili.com/video/BV1kR4y1b7Qc?p=60&vd_source=eb0f3f74a814cc08c9f323d51f922175">    <div class="tag-link-tips">引用站外地址</div>    <div class="tag-link-bottom">        <div class="tag-link-left" style="background-image: url(https://api.iowen.cn/favicon/www.bilibili.com/video/BV1kR4y1b7Qc?p=60&vd_source=eb0f3f74a814cc08c9f323d51f922175.png);"></div>        <div class="tag-link-right">            <div class="tag-link-title">基于xml的AOP</div>            <div class="tag-link-sitename">bilibili</div>        </div>        <i class="fa-solid fa-angle-right"></i>    </div>    </a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-容器：IoC&quot;&gt;&lt;a href=&quot;#1-容器：IoC&quot; class=&quot;headerlink&quot; title=&quot;1.容器：IoC&quot;&gt;&lt;/a&gt;1.容器：IoC&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;IoC 是 Inversion of Control 的简写，译为“控制反转”，</summary>
      
    
    
    
    <category term="编程Coding" scheme="https://github.wilbur-lz.cn/categories/%E7%BC%96%E7%A8%8BCoding/"/>
    
    
    <category term="Spring学习" scheme="https://github.wilbur-lz.cn/tags/Spring%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
</feed>
